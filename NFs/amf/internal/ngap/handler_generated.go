// Code generated by ngap_generator.go, DO NOT EDIT.
package ngap

import (
	"github.com/free5gc/amf/internal/context"
	"github.com/free5gc/amf/internal/logger"
	ngap_message "github.com/free5gc/amf/internal/ngap/message"
	"github.com/free5gc/ngap"
	"github.com/free5gc/ngap/ngapType"
)

func handlerAMFConfigurationUpdate(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFName *ngapType.AMFName
	var servedGUAMIList *ngapType.ServedGUAMIList
	var relativeAMFCapacity *ngapType.RelativeAMFCapacity
	var pLMNSupportList *ngapType.PLMNSupportList
	var aMFTNLAssociationToAddList *ngapType.AMFTNLAssociationToAddList
	var aMFTNLAssociationToRemoveList *ngapType.AMFTNLAssociationToRemoveList
	var aMFTNLAssociationToUpdateList *ngapType.AMFTNLAssociationToUpdateList

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	aMFConfigurationUpdate := initiatingMessage.Value.AMFConfigurationUpdate
	if aMFConfigurationUpdate == nil {
		ran.Log.Error("AMFConfigurationUpdate is nil")
		return
	}

	ran.Log.Info("Handle AMFConfigurationUpdate")

	for _, ie := range aMFConfigurationUpdate.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFName: // optional, reject
			if aMFName != nil {
				ran.Log.Error("Duplicate IE AMFName")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFName = ie.Value.AMFName
			ran.Log.Trace("Decode IE AMFName")
		case ngapType.ProtocolIEIDServedGUAMIList: // optional, reject
			if servedGUAMIList != nil {
				ran.Log.Error("Duplicate IE ServedGUAMIList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			servedGUAMIList = ie.Value.ServedGUAMIList
			ran.Log.Trace("Decode IE ServedGUAMIList")
		case ngapType.ProtocolIEIDRelativeAMFCapacity: // optional, ignore
			if relativeAMFCapacity != nil {
				ran.Log.Error("Duplicate IE RelativeAMFCapacity")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			relativeAMFCapacity = ie.Value.RelativeAMFCapacity
			ran.Log.Trace("Decode IE RelativeAMFCapacity")
		case ngapType.ProtocolIEIDPLMNSupportList: // optional, reject
			if pLMNSupportList != nil {
				ran.Log.Error("Duplicate IE PLMNSupportList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pLMNSupportList = ie.Value.PLMNSupportList
			ran.Log.Trace("Decode IE PLMNSupportList")
		case ngapType.ProtocolIEIDAMFTNLAssociationToAddList: // optional, ignore
			if aMFTNLAssociationToAddList != nil {
				ran.Log.Error("Duplicate IE AMF-TNLAssociationToAddList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFTNLAssociationToAddList = ie.Value.AMFTNLAssociationToAddList
			ran.Log.Trace("Decode IE AMF-TNLAssociationToAddList")
		case ngapType.ProtocolIEIDAMFTNLAssociationToRemoveList: // optional, ignore
			if aMFTNLAssociationToRemoveList != nil {
				ran.Log.Error("Duplicate IE AMF-TNLAssociationToRemoveList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFTNLAssociationToRemoveList = ie.Value.AMFTNLAssociationToRemoveList
			ran.Log.Trace("Decode IE AMF-TNLAssociationToRemoveList")
		case ngapType.ProtocolIEIDAMFTNLAssociationToUpdateList: // optional, ignore
			if aMFTNLAssociationToUpdateList != nil {
				ran.Log.Error("Duplicate IE AMF-TNLAssociationToUpdateList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFTNLAssociationToUpdateList = ie.Value.AMFTNLAssociationToUpdateList
			ran.Log.Trace("Decode IE AMF-TNLAssociationToUpdateList")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeAMFConfigurationUpdate
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleAMFConfigurationUpdateMain(ran *context.AmfRan,
	//	aMFName *ngapType.AMFName,
	//	servedGUAMIList *ngapType.ServedGUAMIList,
	//	relativeAMFCapacity *ngapType.RelativeAMFCapacity,
	//	pLMNSupportList *ngapType.PLMNSupportList,
	//	aMFTNLAssociationToAddList *ngapType.AMFTNLAssociationToAddList,
	//	aMFTNLAssociationToRemoveList *ngapType.AMFTNLAssociationToRemoveList,
	//	aMFTNLAssociationToUpdateList *ngapType.AMFTNLAssociationToUpdateList) {
	handleAMFConfigurationUpdateMain(ran, aMFName /* may be nil */, servedGUAMIList /* may be nil */, relativeAMFCapacity /* may be nil */, pLMNSupportList /* may be nil */, aMFTNLAssociationToAddList /* may be nil */, aMFTNLAssociationToRemoveList /* may be nil */, aMFTNLAssociationToUpdateList /* may be nil */)
}

func handleAMFConfigurationUpdateMain(ran *context.AmfRan, aMFName *ngapType.AMFName, servedGUAMIList *ngapType.ServedGUAMIList, relativeAMFCapacity *ngapType.RelativeAMFCapacity, pLMNSupportList *ngapType.PLMNSupportList, aMFTNLAssociationToAddList *ngapType.AMFTNLAssociationToAddList, aMFTNLAssociationToRemoveList *ngapType.AMFTNLAssociationToRemoveList, aMFTNLAssociationToUpdateList *ngapType.AMFTNLAssociationToUpdateList) {
	ran.Log.Error("Handle AMFConfigurationUpdate: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeAMFConfigurationUpdate
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerAMFConfigurationUpdateAcknowledge(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFTNLAssociationSetupList *ngapType.AMFTNLAssociationSetupList
	var aMFTNLAssociationFailedToSetupList *ngapType.TNLAssociationList
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	aMFConfigurationUpdateAcknowledge := successfulOutcome.Value.AMFConfigurationUpdateAcknowledge
	if aMFConfigurationUpdateAcknowledge == nil {
		ran.Log.Error("AMFConfigurationUpdateAcknowledge is nil")
		return
	}

	ran.Log.Info("Handle AMFConfigurationUpdateAcknowledge")

	for _, ie := range aMFConfigurationUpdateAcknowledge.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFTNLAssociationSetupList: // optional, ignore
			if aMFTNLAssociationSetupList != nil {
				ran.Log.Error("Duplicate IE AMF-TNLAssociationSetupList")
				abort = true
				break
			}
			aMFTNLAssociationSetupList = ie.Value.AMFTNLAssociationSetupList
			ran.Log.Trace("Decode IE AMF-TNLAssociationSetupList")
		case ngapType.ProtocolIEIDAMFTNLAssociationFailedToSetupList: // optional, ignore
			if aMFTNLAssociationFailedToSetupList != nil {
				ran.Log.Error("Duplicate IE TNLAssociationList")
				abort = true
				break
			}
			aMFTNLAssociationFailedToSetupList = ie.Value.AMFTNLAssociationFailedToSetupList
			ran.Log.Trace("Decode IE TNLAssociationList")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeAMFConfigurationUpdate
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFTNLAssociationSetupList != nil {
		ran.Log.Warn("IE AMF-TNLAssociationSetupList is not implemented")
	}
	if aMFTNLAssociationFailedToSetupList != nil {
		ran.Log.Warn("IE TNLAssociationList is not implemented")
	}

	// func handleAMFConfigurationUpdateAcknowledgeMain(ran *context.AmfRan,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleAMFConfigurationUpdateAcknowledgeMain(ran, criticalityDiagnostics /* may be nil */)
}

func handlerAMFConfigurationUpdateFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var cause *ngapType.Cause
	var timeToWait *ngapType.TimeToWait
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	aMFConfigurationUpdateFailure := unsuccessfulOutcome.Value.AMFConfigurationUpdateFailure
	if aMFConfigurationUpdateFailure == nil {
		ran.Log.Error("AMFConfigurationUpdateFailure is nil")
		return
	}

	ran.Log.Info("Handle AMFConfigurationUpdateFailure")

	for _, ie := range aMFConfigurationUpdateFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDTimeToWait: // optional, ignore
			if timeToWait != nil {
				ran.Log.Error("Duplicate IE TimeToWait")
				abort = true
				break
			}
			timeToWait = ie.Value.TimeToWait
			ran.Log.Trace("Decode IE TimeToWait")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeAMFConfigurationUpdate
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}
	if timeToWait != nil {
		ran.Log.Warn("IE TimeToWait is not implemented")
	}

	// func handleAMFConfigurationUpdateFailureMain(ran *context.AmfRan,
	//	cause *ngapType.Cause,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleAMFConfigurationUpdateFailureMain(ran, cause /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerAMFStatusIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var unavailableGUAMIList *ngapType.UnavailableGUAMIList

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	aMFStatusIndication := initiatingMessage.Value.AMFStatusIndication
	if aMFStatusIndication == nil {
		ran.Log.Error("AMFStatusIndication is nil")
		return
	}

	ran.Log.Info("Handle AMFStatusIndication")

	for _, ie := range aMFStatusIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDUnavailableGUAMIList: // mandatory, reject
			if unavailableGUAMIList != nil {
				ran.Log.Error("Duplicate IE UnavailableGUAMIList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			unavailableGUAMIList = ie.Value.UnavailableGUAMIList
			ran.Log.Trace("Decode IE UnavailableGUAMIList")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if unavailableGUAMIList == nil {
		ran.Log.Error("Missing IE UnavailableGUAMIList")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDUnavailableGUAMIList, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeAMFStatusIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if unavailableGUAMIList == nil {
		ran.Log.Error("Missing IE UnavailableGUAMIList")
		return
	}

	// func handleAMFStatusIndicationMain(ran *context.AmfRan,
	//	unavailableGUAMIList *ngapType.UnavailableGUAMIList) {
	handleAMFStatusIndicationMain(ran, unavailableGUAMIList)
}

func handleAMFStatusIndicationMain(ran *context.AmfRan, unavailableGUAMIList *ngapType.UnavailableGUAMIList) {
	ran.Log.Error("Handle AMFStatusIndication: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeAMFStatusIndication
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerCellTrafficTrace(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var nGRANTraceID *ngapType.NGRANTraceID
	var nGRANCGI *ngapType.NGRANCGI
	var traceCollectionEntityIPAddress *ngapType.TransportLayerAddress

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	cellTrafficTrace := initiatingMessage.Value.CellTrafficTrace
	if cellTrafficTrace == nil {
		ran.Log.Error("CellTrafficTrace is nil")
		return
	}

	ran.Log.Info("Handle CellTrafficTrace")

	for _, ie := range cellTrafficTrace.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDNGRANTraceID: // mandatory, ignore
			if nGRANTraceID != nil {
				ran.Log.Error("Duplicate IE NGRANTraceID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nGRANTraceID = ie.Value.NGRANTraceID
			ran.Log.Trace("Decode IE NGRANTraceID")
		case ngapType.ProtocolIEIDNGRANCGI: // mandatory, ignore
			if nGRANCGI != nil {
				ran.Log.Error("Duplicate IE NGRAN-CGI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nGRANCGI = ie.Value.NGRANCGI
			ran.Log.Trace("Decode IE NGRAN-CGI")
		case ngapType.ProtocolIEIDTraceCollectionEntityIPAddress: // mandatory, ignore
			if traceCollectionEntityIPAddress != nil {
				ran.Log.Error("Duplicate IE TransportLayerAddress")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			traceCollectionEntityIPAddress = ie.Value.TraceCollectionEntityIPAddress
			ran.Log.Trace("Decode IE TransportLayerAddress")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeCellTrafficTrace
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nGRANTraceID == nil {
		ran.Log.Warn("Missing IE NGRANTraceID")
	}
	if nGRANCGI == nil {
		ran.Log.Warn("Missing IE NGRAN-CGI")
	}
	if traceCollectionEntityIPAddress == nil {
		ran.Log.Warn("Missing IE TransportLayerAddress")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle CellTrafficTrace: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle CellTrafficTrace: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle CellTrafficTrace (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleCellTrafficTraceMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	nGRANTraceID *ngapType.NGRANTraceID,
	//	nGRANCGI *ngapType.NGRANCGI,
	//	traceCollectionEntityIPAddress *ngapType.TransportLayerAddress) {
	handleCellTrafficTraceMain(ran, ranUe, nGRANTraceID /* may be nil */, nGRANCGI /* may be nil */, traceCollectionEntityIPAddress /* may be nil */)
}

func handlerDeactivateTrace(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var nGRANTraceID *ngapType.NGRANTraceID

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	deactivateTrace := initiatingMessage.Value.DeactivateTrace
	if deactivateTrace == nil {
		ran.Log.Error("DeactivateTrace is nil")
		return
	}

	ran.Log.Info("Handle DeactivateTrace")

	for _, ie := range deactivateTrace.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDNGRANTraceID: // mandatory, ignore
			if nGRANTraceID != nil {
				ran.Log.Error("Duplicate IE NGRANTraceID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nGRANTraceID = ie.Value.NGRANTraceID
			ran.Log.Trace("Decode IE NGRANTraceID")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeDeactivateTrace
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nGRANTraceID == nil {
		ran.Log.Warn("Missing IE NGRANTraceID")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle DeactivateTrace: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle DeactivateTrace: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle DeactivateTrace (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleDeactivateTraceMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	nGRANTraceID *ngapType.NGRANTraceID) {
	handleDeactivateTraceMain(ran, ranUe, nGRANTraceID /* may be nil */)
}

func handleDeactivateTraceMain(ran *context.AmfRan, ranUe *context.RanUe, nGRANTraceID *ngapType.NGRANTraceID) {
	ran.Log.Error("Handle DeactivateTrace: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeDeactivateTrace
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerDownlinkNASTransport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var oldAMF *ngapType.AMFName
	var rANPagingPriority *ngapType.RANPagingPriority
	var nASPDU *ngapType.NASPDU
	var mobilityRestrictionList *ngapType.MobilityRestrictionList
	var indexToRFSP *ngapType.IndexToRFSP
	var uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate
	var allowedNSSAI *ngapType.AllowedNSSAI

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	downlinkNASTransport := initiatingMessage.Value.DownlinkNASTransport
	if downlinkNASTransport == nil {
		ran.Log.Error("DownlinkNASTransport is nil")
		return
	}

	ran.Log.Info("Handle DownlinkNASTransport")

	for _, ie := range downlinkNASTransport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDOldAMF: // optional, reject
			if oldAMF != nil {
				ran.Log.Error("Duplicate IE AMFName")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			oldAMF = ie.Value.OldAMF
			ran.Log.Trace("Decode IE AMFName")
		case ngapType.ProtocolIEIDRANPagingPriority: // optional, ignore
			if rANPagingPriority != nil {
				ran.Log.Error("Duplicate IE RANPagingPriority")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANPagingPriority = ie.Value.RANPagingPriority
			ran.Log.Trace("Decode IE RANPagingPriority")
		case ngapType.ProtocolIEIDNASPDU: // mandatory, reject
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDMobilityRestrictionList: // optional, ignore
			if mobilityRestrictionList != nil {
				ran.Log.Error("Duplicate IE MobilityRestrictionList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			mobilityRestrictionList = ie.Value.MobilityRestrictionList
			ran.Log.Trace("Decode IE MobilityRestrictionList")
		case ngapType.ProtocolIEIDIndexToRFSP: // optional, ignore
			if indexToRFSP != nil {
				ran.Log.Error("Duplicate IE IndexToRFSP")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			indexToRFSP = ie.Value.IndexToRFSP
			ran.Log.Trace("Decode IE IndexToRFSP")
		case ngapType.ProtocolIEIDUEAggregateMaximumBitRate: // optional, ignore
			if uEAggregateMaximumBitRate != nil {
				ran.Log.Error("Duplicate IE UEAggregateMaximumBitRate")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEAggregateMaximumBitRate = ie.Value.UEAggregateMaximumBitRate
			ran.Log.Trace("Decode IE UEAggregateMaximumBitRate")
		case ngapType.ProtocolIEIDAllowedNSSAI: // optional, reject
			if allowedNSSAI != nil {
				ran.Log.Error("Duplicate IE AllowedNSSAI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			allowedNSSAI = ie.Value.AllowedNSSAI
			ran.Log.Trace("Decode IE AllowedNSSAI")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nASPDU == nil {
		ran.Log.Error("Missing IE NAS-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNASPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeDownlinkNASTransport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nASPDU == nil {
		ran.Log.Error("Missing IE NAS-PDU")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle DownlinkNASTransport: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle DownlinkNASTransport: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle DownlinkNASTransport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleDownlinkNASTransportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	oldAMF *ngapType.AMFName,
	//	rANPagingPriority *ngapType.RANPagingPriority,
	//	nASPDU *ngapType.NASPDU,
	//	mobilityRestrictionList *ngapType.MobilityRestrictionList,
	//	indexToRFSP *ngapType.IndexToRFSP,
	//	uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate,
	//	allowedNSSAI *ngapType.AllowedNSSAI) {
	handleDownlinkNASTransportMain(ran, ranUe, oldAMF /* may be nil */, rANPagingPriority /* may be nil */, nASPDU, mobilityRestrictionList /* may be nil */, indexToRFSP /* may be nil */, uEAggregateMaximumBitRate /* may be nil */, allowedNSSAI /* may be nil */)
}

func handleDownlinkNASTransportMain(ran *context.AmfRan, ranUe *context.RanUe, oldAMF *ngapType.AMFName, rANPagingPriority *ngapType.RANPagingPriority, nASPDU *ngapType.NASPDU, mobilityRestrictionList *ngapType.MobilityRestrictionList, indexToRFSP *ngapType.IndexToRFSP, uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate, allowedNSSAI *ngapType.AllowedNSSAI) {
	ran.Log.Error("Handle DownlinkNASTransport: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeDownlinkNASTransport
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerDownlinkNonUEAssociatedNRPPaTransport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var routingID *ngapType.RoutingID
	var nRPPaPDU *ngapType.NRPPaPDU

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	downlinkNonUEAssociatedNRPPaTransport := initiatingMessage.Value.DownlinkNonUEAssociatedNRPPaTransport
	if downlinkNonUEAssociatedNRPPaTransport == nil {
		ran.Log.Error("DownlinkNonUEAssociatedNRPPaTransport is nil")
		return
	}

	ran.Log.Info("Handle DownlinkNonUEAssociatedNRPPaTransport")

	for _, ie := range downlinkNonUEAssociatedNRPPaTransport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDRoutingID: // mandatory, reject
			if routingID != nil {
				ran.Log.Error("Duplicate IE RoutingID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			routingID = ie.Value.RoutingID
			ran.Log.Trace("Decode IE RoutingID")
		case ngapType.ProtocolIEIDNRPPaPDU: // mandatory, reject
			if nRPPaPDU != nil {
				ran.Log.Error("Duplicate IE NRPPa-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nRPPaPDU = ie.Value.NRPPaPDU
			ran.Log.Trace("Decode IE NRPPa-PDU")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRoutingID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNRPPaPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeDownlinkNonUEAssociatedNRPPaTransport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		return
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		return
	}

	// func handleDownlinkNonUEAssociatedNRPPaTransportMain(ran *context.AmfRan,
	//	routingID *ngapType.RoutingID,
	//	nRPPaPDU *ngapType.NRPPaPDU) {
	handleDownlinkNonUEAssociatedNRPPaTransportMain(ran, routingID, nRPPaPDU)
}

func handleDownlinkNonUEAssociatedNRPPaTransportMain(ran *context.AmfRan, routingID *ngapType.RoutingID, nRPPaPDU *ngapType.NRPPaPDU) {
	ran.Log.Error("Handle DownlinkNonUEAssociatedNRPPaTransport: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeDownlinkNonUEAssociatedNRPPaTransport
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerDownlinkRANConfigurationTransfer(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var sONConfigurationTransferDL *ngapType.SONConfigurationTransfer
	var eNDCSONConfigurationTransferDL *ngapType.ENDCSONConfigurationTransfer

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	downlinkRANConfigurationTransfer := initiatingMessage.Value.DownlinkRANConfigurationTransfer
	if downlinkRANConfigurationTransfer == nil {
		ran.Log.Error("DownlinkRANConfigurationTransfer is nil")
		return
	}

	ran.Log.Info("Handle DownlinkRANConfigurationTransfer")

	for _, ie := range downlinkRANConfigurationTransfer.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDSONConfigurationTransferDL: // optional, ignore
			if sONConfigurationTransferDL != nil {
				ran.Log.Error("Duplicate IE SONConfigurationTransfer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			sONConfigurationTransferDL = ie.Value.SONConfigurationTransferDL
			ran.Log.Trace("Decode IE SONConfigurationTransfer")
		case ngapType.ProtocolIEIDENDCSONConfigurationTransferDL: // optional, ignore
			if eNDCSONConfigurationTransferDL != nil {
				ran.Log.Error("Duplicate IE EN-DCSONConfigurationTransfer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			eNDCSONConfigurationTransferDL = ie.Value.ENDCSONConfigurationTransferDL
			ran.Log.Trace("Decode IE EN-DCSONConfigurationTransfer")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeDownlinkRANConfigurationTransfer
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleDownlinkRANConfigurationTransferMain(ran *context.AmfRan,
	//	sONConfigurationTransferDL *ngapType.SONConfigurationTransfer,
	//	eNDCSONConfigurationTransferDL *ngapType.ENDCSONConfigurationTransfer) {
	handleDownlinkRANConfigurationTransferMain(ran, sONConfigurationTransferDL /* may be nil */, eNDCSONConfigurationTransferDL /* may be nil */)
}

func handleDownlinkRANConfigurationTransferMain(ran *context.AmfRan, sONConfigurationTransferDL *ngapType.SONConfigurationTransfer, eNDCSONConfigurationTransferDL *ngapType.ENDCSONConfigurationTransfer) {
	ran.Log.Error("Handle DownlinkRANConfigurationTransfer: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeDownlinkRANConfigurationTransfer
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerDownlinkRANStatusTransfer(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rANStatusTransferTransparentContainer *ngapType.RANStatusTransferTransparentContainer

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	downlinkRANStatusTransfer := initiatingMessage.Value.DownlinkRANStatusTransfer
	if downlinkRANStatusTransfer == nil {
		ran.Log.Error("DownlinkRANStatusTransfer is nil")
		return
	}

	ran.Log.Info("Handle DownlinkRANStatusTransfer")

	for _, ie := range downlinkRANStatusTransfer.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANStatusTransferTransparentContainer: // mandatory, reject
			if rANStatusTransferTransparentContainer != nil {
				ran.Log.Error("Duplicate IE RANStatusTransfer-TransparentContainer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANStatusTransferTransparentContainer = ie.Value.RANStatusTransferTransparentContainer
			ran.Log.Trace("Decode IE RANStatusTransfer-TransparentContainer")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANStatusTransferTransparentContainer == nil {
		ran.Log.Error("Missing IE RANStatusTransfer-TransparentContainer")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANStatusTransferTransparentContainer, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeDownlinkRANStatusTransfer
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if rANStatusTransferTransparentContainer == nil {
		ran.Log.Error("Missing IE RANStatusTransfer-TransparentContainer")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle DownlinkRANStatusTransfer: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle DownlinkRANStatusTransfer: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle DownlinkRANStatusTransfer (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleDownlinkRANStatusTransferMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rANStatusTransferTransparentContainer *ngapType.RANStatusTransferTransparentContainer) {
	handleDownlinkRANStatusTransferMain(ran, ranUe, rANStatusTransferTransparentContainer)
}

func handleDownlinkRANStatusTransferMain(ran *context.AmfRan, ranUe *context.RanUe, rANStatusTransferTransparentContainer *ngapType.RANStatusTransferTransparentContainer) {
	ran.Log.Error("Handle DownlinkRANStatusTransfer: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeDownlinkRANStatusTransfer
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerDownlinkUEAssociatedNRPPaTransport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var routingID *ngapType.RoutingID
	var nRPPaPDU *ngapType.NRPPaPDU

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	downlinkUEAssociatedNRPPaTransport := initiatingMessage.Value.DownlinkUEAssociatedNRPPaTransport
	if downlinkUEAssociatedNRPPaTransport == nil {
		ran.Log.Error("DownlinkUEAssociatedNRPPaTransport is nil")
		return
	}

	ran.Log.Info("Handle DownlinkUEAssociatedNRPPaTransport")

	for _, ie := range downlinkUEAssociatedNRPPaTransport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRoutingID: // mandatory, reject
			if routingID != nil {
				ran.Log.Error("Duplicate IE RoutingID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			routingID = ie.Value.RoutingID
			ran.Log.Trace("Decode IE RoutingID")
		case ngapType.ProtocolIEIDNRPPaPDU: // mandatory, reject
			if nRPPaPDU != nil {
				ran.Log.Error("Duplicate IE NRPPa-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nRPPaPDU = ie.Value.NRPPaPDU
			ran.Log.Trace("Decode IE NRPPa-PDU")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRoutingID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNRPPaPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeDownlinkUEAssociatedNRPPaTransport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		return
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle DownlinkUEAssociatedNRPPaTransport: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle DownlinkUEAssociatedNRPPaTransport: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle DownlinkUEAssociatedNRPPaTransport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleDownlinkUEAssociatedNRPPaTransportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	routingID *ngapType.RoutingID,
	//	nRPPaPDU *ngapType.NRPPaPDU) {
	handleDownlinkUEAssociatedNRPPaTransportMain(ran, ranUe, routingID, nRPPaPDU)
}

func handleDownlinkUEAssociatedNRPPaTransportMain(ran *context.AmfRan, ranUe *context.RanUe, routingID *ngapType.RoutingID, nRPPaPDU *ngapType.NRPPaPDU) {
	ran.Log.Error("Handle DownlinkUEAssociatedNRPPaTransport: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeDownlinkUEAssociatedNRPPaTransport
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerErrorIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var cause *ngapType.Cause
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	errorIndication := initiatingMessage.Value.ErrorIndication
	if errorIndication == nil {
		ran.Log.Error("ErrorIndication is nil")
		return
	}

	ran.Log.Info("Handle ErrorIndication")

	for _, ie := range errorIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // optional, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // optional, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCause: // optional, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeErrorIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleErrorIndicationMain(ran *context.AmfRan,
	//	aMFUENGAPID *ngapType.AMFUENGAPID,
	//	rANUENGAPID *ngapType.RANUENGAPID,
	//	cause *ngapType.Cause,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleErrorIndicationMain(ran, aMFUENGAPID /* may be nil */, rANUENGAPID /* may be nil */, cause /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerHandoverCancel(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var cause *ngapType.Cause

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverCancel := initiatingMessage.Value.HandoverCancel
	if handoverCancel == nil {
		ran.Log.Error("HandoverCancel is nil")
		return
	}

	ran.Log.Info("Handle HandoverCancel")

	for _, ie := range handoverCancel.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverCancel
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle HandoverCancel: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle HandoverCancel: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle HandoverCancel (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleHandoverCancelMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	cause *ngapType.Cause) {
	handleHandoverCancelMain(ran, ranUe, cause /* may be nil */)
}

func handlerHandoverCancelAcknowledge(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverCancelAcknowledge := successfulOutcome.Value.HandoverCancelAcknowledge
	if handoverCancelAcknowledge == nil {
		ran.Log.Error("HandoverCancelAcknowledge is nil")
		return
	}

	ran.Log.Info("Handle HandoverCancelAcknowledge")

	for _, ie := range handoverCancelAcknowledge.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverCancel
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle HandoverCancelAcknowledge: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle HandoverCancelAcknowledge: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle HandoverCancelAcknowledge (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleHandoverCancelAcknowledgeMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleHandoverCancelAcknowledgeMain(ran, ranUe /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handleHandoverCancelAcknowledgeMain(ran *context.AmfRan, ranUe *context.RanUe, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle HandoverCancelAcknowledge: AMF to RAN message")
}

func handlerHandoverCommand(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var handoverType *ngapType.HandoverType
	var nASSecurityParametersFromNGRAN *ngapType.NASSecurityParametersFromNGRAN
	var pDUSessionResourceHandoverList *ngapType.PDUSessionResourceHandoverList
	var pDUSessionResourceToReleaseListHOCmd *ngapType.PDUSessionResourceToReleaseListHOCmd
	var targetToSourceTransparentContainer *ngapType.TargetToSourceTransparentContainer
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverCommand := successfulOutcome.Value.HandoverCommand
	if handoverCommand == nil {
		ran.Log.Error("HandoverCommand is nil")
		return
	}

	ran.Log.Info("Handle HandoverCommand")

	for _, ie := range handoverCommand.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDHandoverType: // mandatory, reject
			if handoverType != nil {
				ran.Log.Error("Duplicate IE HandoverType")
				abort = true
				break
			}
			handoverType = ie.Value.HandoverType
			ran.Log.Trace("Decode IE HandoverType")
		case ngapType.ProtocolIEIDNASSecurityParametersFromNGRAN: // conditional, reject
			if nASSecurityParametersFromNGRAN != nil {
				ran.Log.Error("Duplicate IE NASSecurityParametersFromNGRAN")
				abort = true
				break
			}
			nASSecurityParametersFromNGRAN = ie.Value.NASSecurityParametersFromNGRAN
			ran.Log.Trace("Decode IE NASSecurityParametersFromNGRAN")
		case ngapType.ProtocolIEIDPDUSessionResourceHandoverList: // optional, ignore
			if pDUSessionResourceHandoverList != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceHandoverList")
				abort = true
				break
			}
			pDUSessionResourceHandoverList = ie.Value.PDUSessionResourceHandoverList
			ran.Log.Trace("Decode IE PDUSessionResourceHandoverList")
		case ngapType.ProtocolIEIDPDUSessionResourceToReleaseListHOCmd: // optional, ignore
			if pDUSessionResourceToReleaseListHOCmd != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceToReleaseListHOCmd")
				abort = true
				break
			}
			pDUSessionResourceToReleaseListHOCmd = ie.Value.PDUSessionResourceToReleaseListHOCmd
			ran.Log.Trace("Decode IE PDUSessionResourceToReleaseListHOCmd")
		case ngapType.ProtocolIEIDTargetToSourceTransparentContainer: // mandatory, reject
			if targetToSourceTransparentContainer != nil {
				ran.Log.Error("Duplicate IE TargetToSource-TransparentContainer")
				abort = true
				break
			}
			targetToSourceTransparentContainer = ie.Value.TargetToSourceTransparentContainer
			ran.Log.Trace("Decode IE TargetToSource-TransparentContainer")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverPreparation
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if handoverType == nil {
		ran.Log.Error("Missing IE HandoverType")
		return
	}
	if targetToSourceTransparentContainer == nil {
		ran.Log.Error("Missing IE TargetToSource-TransparentContainer")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle HandoverCommand: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle HandoverCommand: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle HandoverCommand (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleHandoverCommandMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	handoverType *ngapType.HandoverType,
	//	nASSecurityParametersFromNGRAN *ngapType.NASSecurityParametersFromNGRAN,
	//	pDUSessionResourceHandoverList *ngapType.PDUSessionResourceHandoverList,
	//	pDUSessionResourceToReleaseListHOCmd *ngapType.PDUSessionResourceToReleaseListHOCmd,
	//	targetToSourceTransparentContainer *ngapType.TargetToSourceTransparentContainer,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleHandoverCommandMain(ran, ranUe, handoverType, nASSecurityParametersFromNGRAN /* may be nil */, pDUSessionResourceHandoverList /* may be nil */, pDUSessionResourceToReleaseListHOCmd /* may be nil */, targetToSourceTransparentContainer, criticalityDiagnostics /* may be nil */)
}

func handleHandoverCommandMain(ran *context.AmfRan, ranUe *context.RanUe, handoverType *ngapType.HandoverType, nASSecurityParametersFromNGRAN *ngapType.NASSecurityParametersFromNGRAN, pDUSessionResourceHandoverList *ngapType.PDUSessionResourceHandoverList, pDUSessionResourceToReleaseListHOCmd *ngapType.PDUSessionResourceToReleaseListHOCmd, targetToSourceTransparentContainer *ngapType.TargetToSourceTransparentContainer, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle HandoverCommand: AMF to RAN message")
}

func handlerHandoverFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var cause *ngapType.Cause
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverFailure := unsuccessfulOutcome.Value.HandoverFailure
	if handoverFailure == nil {
		ran.Log.Error("HandoverFailure is nil")
		return
	}

	ran.Log.Info("Handle HandoverFailure")

	for _, ie := range handoverFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverResourceAllocation
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, nil, true, true)
		if err != nil {
			ran.Log.Errorf("Handle HandoverFailure: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle HandoverFailure: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle HandoverFailure (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleHandoverFailureMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	cause *ngapType.Cause,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleHandoverFailureMain(ran, ranUe /* may be nil */, cause /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerHandoverNotify(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var userLocationInformation *ngapType.UserLocationInformation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverNotify := initiatingMessage.Value.HandoverNotify
	if handoverNotify == nil {
		ran.Log.Error("HandoverNotify is nil")
		return
	}

	ran.Log.Info("Handle HandoverNotify")

	for _, ie := range handoverNotify.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUserLocationInformation: // mandatory, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverNotification
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if userLocationInformation == nil {
		ran.Log.Warn("Missing IE UserLocationInformation")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle HandoverNotify: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle HandoverNotify: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle HandoverNotify (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleHandoverNotifyMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	userLocationInformation *ngapType.UserLocationInformation) {
	handleHandoverNotifyMain(ran, ranUe, userLocationInformation /* may be nil */)
}

func handlerHandoverPreparationFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var cause *ngapType.Cause
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverPreparationFailure := unsuccessfulOutcome.Value.HandoverPreparationFailure
	if handoverPreparationFailure == nil {
		ran.Log.Error("HandoverPreparationFailure is nil")
		return
	}

	ran.Log.Info("Handle HandoverPreparationFailure")

	for _, ie := range handoverPreparationFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverPreparation
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle HandoverPreparationFailure: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle HandoverPreparationFailure: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle HandoverPreparationFailure (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleHandoverPreparationFailureMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	cause *ngapType.Cause,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleHandoverPreparationFailureMain(ran, ranUe /* may be nil */, cause /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handleHandoverPreparationFailureMain(ran *context.AmfRan, ranUe *context.RanUe, cause *ngapType.Cause, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle HandoverPreparationFailure: AMF to RAN message")
}

func handlerHandoverRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var handoverType *ngapType.HandoverType
	var cause *ngapType.Cause
	var uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate
	var coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation
	var uESecurityCapabilities *ngapType.UESecurityCapabilities
	var securityContext *ngapType.SecurityContext
	var newSecurityContextInd *ngapType.NewSecurityContextInd
	var nASC *ngapType.NASPDU
	var pDUSessionResourceSetupListHOReq *ngapType.PDUSessionResourceSetupListHOReq
	var allowedNSSAI *ngapType.AllowedNSSAI
	var traceActivation *ngapType.TraceActivation
	var maskedIMEISV *ngapType.MaskedIMEISV
	var sourceToTargetTransparentContainer *ngapType.SourceToTargetTransparentContainer
	var mobilityRestrictionList *ngapType.MobilityRestrictionList
	var locationReportingRequestType *ngapType.LocationReportingRequestType
	var rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest
	var gUAMI *ngapType.GUAMI
	var redirectionVoiceFallback *ngapType.RedirectionVoiceFallback

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverRequest := initiatingMessage.Value.HandoverRequest
	if handoverRequest == nil {
		ran.Log.Error("HandoverRequest is nil")
		return
	}

	ran.Log.Info("Handle HandoverRequest")

	for _, ie := range handoverRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDHandoverType: // mandatory, reject
			if handoverType != nil {
				ran.Log.Error("Duplicate IE HandoverType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			handoverType = ie.Value.HandoverType
			ran.Log.Trace("Decode IE HandoverType")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDUEAggregateMaximumBitRate: // mandatory, reject
			if uEAggregateMaximumBitRate != nil {
				ran.Log.Error("Duplicate IE UEAggregateMaximumBitRate")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEAggregateMaximumBitRate = ie.Value.UEAggregateMaximumBitRate
			ran.Log.Trace("Decode IE UEAggregateMaximumBitRate")
		case ngapType.ProtocolIEIDCoreNetworkAssistanceInformation: // optional, ignore
			if coreNetworkAssistanceInformation != nil {
				ran.Log.Error("Duplicate IE CoreNetworkAssistanceInformationForInactive")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			coreNetworkAssistanceInformation = ie.Value.CoreNetworkAssistanceInformation
			ran.Log.Trace("Decode IE CoreNetworkAssistanceInformationForInactive")
		case ngapType.ProtocolIEIDUESecurityCapabilities: // mandatory, reject
			if uESecurityCapabilities != nil {
				ran.Log.Error("Duplicate IE UESecurityCapabilities")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uESecurityCapabilities = ie.Value.UESecurityCapabilities
			ran.Log.Trace("Decode IE UESecurityCapabilities")
		case ngapType.ProtocolIEIDSecurityContext: // mandatory, reject
			if securityContext != nil {
				ran.Log.Error("Duplicate IE SecurityContext")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			securityContext = ie.Value.SecurityContext
			ran.Log.Trace("Decode IE SecurityContext")
		case ngapType.ProtocolIEIDNewSecurityContextInd: // optional, reject
			if newSecurityContextInd != nil {
				ran.Log.Error("Duplicate IE NewSecurityContextInd")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			newSecurityContextInd = ie.Value.NewSecurityContextInd
			ran.Log.Trace("Decode IE NewSecurityContextInd")
		case ngapType.ProtocolIEIDNASC: // optional, reject
			if nASC != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASC = ie.Value.NASC
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDPDUSessionResourceSetupListHOReq: // mandatory, reject
			if pDUSessionResourceSetupListHOReq != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSetupListHOReq")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceSetupListHOReq = ie.Value.PDUSessionResourceSetupListHOReq
			ran.Log.Trace("Decode IE PDUSessionResourceSetupListHOReq")
		case ngapType.ProtocolIEIDAllowedNSSAI: // mandatory, reject
			if allowedNSSAI != nil {
				ran.Log.Error("Duplicate IE AllowedNSSAI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			allowedNSSAI = ie.Value.AllowedNSSAI
			ran.Log.Trace("Decode IE AllowedNSSAI")
		case ngapType.ProtocolIEIDTraceActivation: // optional, ignore
			if traceActivation != nil {
				ran.Log.Error("Duplicate IE TraceActivation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			traceActivation = ie.Value.TraceActivation
			ran.Log.Trace("Decode IE TraceActivation")
		case ngapType.ProtocolIEIDMaskedIMEISV: // optional, ignore
			if maskedIMEISV != nil {
				ran.Log.Error("Duplicate IE MaskedIMEISV")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			maskedIMEISV = ie.Value.MaskedIMEISV
			ran.Log.Trace("Decode IE MaskedIMEISV")
		case ngapType.ProtocolIEIDSourceToTargetTransparentContainer: // mandatory, reject
			if sourceToTargetTransparentContainer != nil {
				ran.Log.Error("Duplicate IE SourceToTarget-TransparentContainer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			sourceToTargetTransparentContainer = ie.Value.SourceToTargetTransparentContainer
			ran.Log.Trace("Decode IE SourceToTarget-TransparentContainer")
		case ngapType.ProtocolIEIDMobilityRestrictionList: // optional, ignore
			if mobilityRestrictionList != nil {
				ran.Log.Error("Duplicate IE MobilityRestrictionList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			mobilityRestrictionList = ie.Value.MobilityRestrictionList
			ran.Log.Trace("Decode IE MobilityRestrictionList")
		case ngapType.ProtocolIEIDLocationReportingRequestType: // optional, ignore
			if locationReportingRequestType != nil {
				ran.Log.Error("Duplicate IE LocationReportingRequestType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			locationReportingRequestType = ie.Value.LocationReportingRequestType
			ran.Log.Trace("Decode IE LocationReportingRequestType")
		case ngapType.ProtocolIEIDRRCInactiveTransitionReportRequest: // optional, ignore
			if rRCInactiveTransitionReportRequest != nil {
				ran.Log.Error("Duplicate IE RRCInactiveTransitionReportRequest")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rRCInactiveTransitionReportRequest = ie.Value.RRCInactiveTransitionReportRequest
			ran.Log.Trace("Decode IE RRCInactiveTransitionReportRequest")
		case ngapType.ProtocolIEIDGUAMI: // mandatory, reject
			if gUAMI != nil {
				ran.Log.Error("Duplicate IE GUAMI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			gUAMI = ie.Value.GUAMI
			ran.Log.Trace("Decode IE GUAMI")
		case ngapType.ProtocolIEIDRedirectionVoiceFallback: // optional, ignore
			if redirectionVoiceFallback != nil {
				ran.Log.Error("Duplicate IE RedirectionVoiceFallback")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			redirectionVoiceFallback = ie.Value.RedirectionVoiceFallback
			ran.Log.Trace("Decode IE RedirectionVoiceFallback")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if handoverType == nil {
		ran.Log.Error("Missing IE HandoverType")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDHandoverType, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if uEAggregateMaximumBitRate == nil {
		ran.Log.Error("Missing IE UEAggregateMaximumBitRate")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDUEAggregateMaximumBitRate, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if uESecurityCapabilities == nil {
		ran.Log.Error("Missing IE UESecurityCapabilities")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDUESecurityCapabilities, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if securityContext == nil {
		ran.Log.Error("Missing IE SecurityContext")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSecurityContext, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceSetupListHOReq == nil {
		ran.Log.Error("Missing IE PDUSessionResourceSetupListHOReq")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceSetupListHOReq, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if allowedNSSAI == nil {
		ran.Log.Error("Missing IE AllowedNSSAI")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAllowedNSSAI, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if sourceToTargetTransparentContainer == nil {
		ran.Log.Error("Missing IE SourceToTarget-TransparentContainer")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSourceToTargetTransparentContainer, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if gUAMI == nil {
		ran.Log.Error("Missing IE GUAMI")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDGUAMI, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverResourceAllocation
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if handoverType == nil {
		ran.Log.Error("Missing IE HandoverType")
		return
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}
	if uEAggregateMaximumBitRate == nil {
		ran.Log.Error("Missing IE UEAggregateMaximumBitRate")
		return
	}
	if uESecurityCapabilities == nil {
		ran.Log.Error("Missing IE UESecurityCapabilities")
		return
	}
	if securityContext == nil {
		ran.Log.Error("Missing IE SecurityContext")
		return
	}
	if pDUSessionResourceSetupListHOReq == nil {
		ran.Log.Error("Missing IE PDUSessionResourceSetupListHOReq")
		return
	}
	if allowedNSSAI == nil {
		ran.Log.Error("Missing IE AllowedNSSAI")
		return
	}
	if sourceToTargetTransparentContainer == nil {
		ran.Log.Error("Missing IE SourceToTarget-TransparentContainer")
		return
	}
	if gUAMI == nil {
		ran.Log.Error("Missing IE GUAMI")
		return
	}

	// AMF: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, nil, false, true)
	if err != nil {
		ran.Log.Errorf("Handle HandoverRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle HandoverRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle HandoverRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleHandoverRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	handoverType *ngapType.HandoverType,
	//	cause *ngapType.Cause,
	//	uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate,
	//	coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation,
	//	uESecurityCapabilities *ngapType.UESecurityCapabilities,
	//	securityContext *ngapType.SecurityContext,
	//	newSecurityContextInd *ngapType.NewSecurityContextInd,
	//	nASC *ngapType.NASPDU,
	//	pDUSessionResourceSetupListHOReq *ngapType.PDUSessionResourceSetupListHOReq,
	//	allowedNSSAI *ngapType.AllowedNSSAI,
	//	traceActivation *ngapType.TraceActivation,
	//	maskedIMEISV *ngapType.MaskedIMEISV,
	//	sourceToTargetTransparentContainer *ngapType.SourceToTargetTransparentContainer,
	//	mobilityRestrictionList *ngapType.MobilityRestrictionList,
	//	locationReportingRequestType *ngapType.LocationReportingRequestType,
	//	rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest,
	//	gUAMI *ngapType.GUAMI,
	//	redirectionVoiceFallback *ngapType.RedirectionVoiceFallback) {
	handleHandoverRequestMain(ran, ranUe, handoverType, cause /* may be nil */, uEAggregateMaximumBitRate, coreNetworkAssistanceInformation /* may be nil */, uESecurityCapabilities, securityContext, newSecurityContextInd /* may be nil */, nASC /* may be nil */, pDUSessionResourceSetupListHOReq, allowedNSSAI, traceActivation /* may be nil */, maskedIMEISV /* may be nil */, sourceToTargetTransparentContainer, mobilityRestrictionList /* may be nil */, locationReportingRequestType /* may be nil */, rRCInactiveTransitionReportRequest /* may be nil */, gUAMI, redirectionVoiceFallback /* may be nil */)
}

func handleHandoverRequestMain(ran *context.AmfRan, ranUe *context.RanUe, handoverType *ngapType.HandoverType, cause *ngapType.Cause, uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate, coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation, uESecurityCapabilities *ngapType.UESecurityCapabilities, securityContext *ngapType.SecurityContext, newSecurityContextInd *ngapType.NewSecurityContextInd, nASC *ngapType.NASPDU, pDUSessionResourceSetupListHOReq *ngapType.PDUSessionResourceSetupListHOReq, allowedNSSAI *ngapType.AllowedNSSAI, traceActivation *ngapType.TraceActivation, maskedIMEISV *ngapType.MaskedIMEISV, sourceToTargetTransparentContainer *ngapType.SourceToTargetTransparentContainer, mobilityRestrictionList *ngapType.MobilityRestrictionList, locationReportingRequestType *ngapType.LocationReportingRequestType, rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest, gUAMI *ngapType.GUAMI, redirectionVoiceFallback *ngapType.RedirectionVoiceFallback) {
	ran.Log.Error("Handle HandoverRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeHandoverResourceAllocation
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerHandoverRequestAcknowledge(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceAdmittedList *ngapType.PDUSessionResourceAdmittedList
	var pDUSessionResourceFailedToSetupListHOAck *ngapType.PDUSessionResourceFailedToSetupListHOAck
	var targetToSourceTransparentContainer *ngapType.TargetToSourceTransparentContainer
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverRequestAcknowledge := successfulOutcome.Value.HandoverRequestAcknowledge
	if handoverRequestAcknowledge == nil {
		ran.Log.Error("HandoverRequestAcknowledge is nil")
		return
	}

	ran.Log.Info("Handle HandoverRequestAcknowledge")

	for _, ie := range handoverRequestAcknowledge.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceAdmittedList: // mandatory, ignore
			if pDUSessionResourceAdmittedList != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceAdmittedList")
				abort = true
				break
			}
			pDUSessionResourceAdmittedList = ie.Value.PDUSessionResourceAdmittedList
			ran.Log.Trace("Decode IE PDUSessionResourceAdmittedList")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToSetupListHOAck: // optional, ignore
			if pDUSessionResourceFailedToSetupListHOAck != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToSetupListHOAck")
				abort = true
				break
			}
			pDUSessionResourceFailedToSetupListHOAck = ie.Value.PDUSessionResourceFailedToSetupListHOAck
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToSetupListHOAck")
		case ngapType.ProtocolIEIDTargetToSourceTransparentContainer: // mandatory, reject
			if targetToSourceTransparentContainer != nil {
				ran.Log.Error("Duplicate IE TargetToSource-TransparentContainer")
				abort = true
				break
			}
			targetToSourceTransparentContainer = ie.Value.TargetToSourceTransparentContainer
			ran.Log.Trace("Decode IE TargetToSource-TransparentContainer")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverResourceAllocation
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if pDUSessionResourceAdmittedList == nil {
		ran.Log.Warn("Missing IE PDUSessionResourceAdmittedList")
	}
	if targetToSourceTransparentContainer == nil {
		ran.Log.Error("Missing IE TargetToSource-TransparentContainer")
		return
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, true, true)
		if err != nil {
			ran.Log.Errorf("Handle HandoverRequestAcknowledge: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle HandoverRequestAcknowledge: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle HandoverRequestAcknowledge (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleHandoverRequestAcknowledgeMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rANUENGAPID *ngapType.RANUENGAPID,
	//	pDUSessionResourceAdmittedList *ngapType.PDUSessionResourceAdmittedList,
	//	pDUSessionResourceFailedToSetupListHOAck *ngapType.PDUSessionResourceFailedToSetupListHOAck,
	//	targetToSourceTransparentContainer *ngapType.TargetToSourceTransparentContainer,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleHandoverRequestAcknowledgeMain(ran, ranUe /* may be nil */, rANUENGAPID /* may be nil */, pDUSessionResourceAdmittedList /* may be nil */, pDUSessionResourceFailedToSetupListHOAck /* may be nil */, targetToSourceTransparentContainer, criticalityDiagnostics /* may be nil */)
}

func handlerHandoverRequired(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var handoverType *ngapType.HandoverType
	var cause *ngapType.Cause
	var targetID *ngapType.TargetID
	var directForwardingPathAvailability *ngapType.DirectForwardingPathAvailability
	var pDUSessionResourceListHORqd *ngapType.PDUSessionResourceListHORqd
	var sourceToTargetTransparentContainer *ngapType.SourceToTargetTransparentContainer

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	handoverRequired := initiatingMessage.Value.HandoverRequired
	if handoverRequired == nil {
		ran.Log.Error("HandoverRequired is nil")
		return
	}

	ran.Log.Info("Handle HandoverRequired")

	for _, ie := range handoverRequired.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDHandoverType: // mandatory, reject
			if handoverType != nil {
				ran.Log.Error("Duplicate IE HandoverType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			handoverType = ie.Value.HandoverType
			ran.Log.Trace("Decode IE HandoverType")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDTargetID: // mandatory, reject
			if targetID != nil {
				ran.Log.Error("Duplicate IE TargetID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			targetID = ie.Value.TargetID
			ran.Log.Trace("Decode IE TargetID")
		case ngapType.ProtocolIEIDDirectForwardingPathAvailability: // optional, ignore
			if directForwardingPathAvailability != nil {
				ran.Log.Error("Duplicate IE DirectForwardingPathAvailability")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			directForwardingPathAvailability = ie.Value.DirectForwardingPathAvailability
			ran.Log.Trace("Decode IE DirectForwardingPathAvailability")
		case ngapType.ProtocolIEIDPDUSessionResourceListHORqd: // mandatory, reject
			if pDUSessionResourceListHORqd != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceListHORqd")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceListHORqd = ie.Value.PDUSessionResourceListHORqd
			ran.Log.Trace("Decode IE PDUSessionResourceListHORqd")
		case ngapType.ProtocolIEIDSourceToTargetTransparentContainer: // mandatory, reject
			if sourceToTargetTransparentContainer != nil {
				ran.Log.Error("Duplicate IE SourceToTarget-TransparentContainer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			sourceToTargetTransparentContainer = ie.Value.SourceToTargetTransparentContainer
			ran.Log.Trace("Decode IE SourceToTarget-TransparentContainer")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if handoverType == nil {
		ran.Log.Error("Missing IE HandoverType")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDHandoverType, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if targetID == nil {
		ran.Log.Error("Missing IE TargetID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDTargetID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceListHORqd == nil {
		ran.Log.Error("Missing IE PDUSessionResourceListHORqd")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceListHORqd, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if sourceToTargetTransparentContainer == nil {
		ran.Log.Error("Missing IE SourceToTarget-TransparentContainer")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSourceToTargetTransparentContainer, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeHandoverPreparation
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		if aMFUENGAPID != nil && rANUENGAPID != nil {
			if syntaxCause == nil {
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
			}
			rawSendHandoverPreparationFailure(ran, *aMFUENGAPID, *rANUENGAPID, *syntaxCause, &criticalityDiagnostics)
		} else {
			ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
		}
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if handoverType == nil {
		ran.Log.Error("Missing IE HandoverType")
		return
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}
	if targetID == nil {
		ran.Log.Error("Missing IE TargetID")
		return
	}
	if directForwardingPathAvailability != nil {
		ran.Log.Warn("IE DirectForwardingPathAvailability is not implemented")
	}
	if pDUSessionResourceListHORqd == nil {
		ran.Log.Error("Missing IE PDUSessionResourceListHORqd")
		return
	}
	if sourceToTargetTransparentContainer == nil {
		ran.Log.Error("Missing IE SourceToTarget-TransparentContainer")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle HandoverRequired: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle HandoverRequired: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle HandoverRequired (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleHandoverRequiredMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	handoverType *ngapType.HandoverType,
	//	cause *ngapType.Cause,
	//	targetID *ngapType.TargetID,
	//	pDUSessionResourceListHORqd *ngapType.PDUSessionResourceListHORqd,
	//	sourceToTargetTransparentContainer *ngapType.SourceToTargetTransparentContainer) {
	handleHandoverRequiredMain(ran, ranUe, handoverType, cause /* may be nil */, targetID, pDUSessionResourceListHORqd, sourceToTargetTransparentContainer)
}

func handlerInitialContextSetupFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceFailedToSetupListCxtFail *ngapType.PDUSessionResourceFailedToSetupListCxtFail
	var cause *ngapType.Cause
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	initialContextSetupFailure := unsuccessfulOutcome.Value.InitialContextSetupFailure
	if initialContextSetupFailure == nil {
		ran.Log.Error("InitialContextSetupFailure is nil")
		return
	}

	ran.Log.Info("Handle InitialContextSetupFailure")

	for _, ie := range initialContextSetupFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToSetupListCxtFail: // optional, ignore
			if pDUSessionResourceFailedToSetupListCxtFail != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToSetupListCxtFail")
				abort = true
				break
			}
			pDUSessionResourceFailedToSetupListCxtFail = ie.Value.PDUSessionResourceFailedToSetupListCxtFail
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToSetupListCxtFail")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeInitialContextSetup
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle InitialContextSetupFailure: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle InitialContextSetupFailure: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle InitialContextSetupFailure (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleInitialContextSetupFailureMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceFailedToSetupListCxtFail *ngapType.PDUSessionResourceFailedToSetupListCxtFail,
	//	cause *ngapType.Cause,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleInitialContextSetupFailureMain(ran, ranUe /* may be nil */, pDUSessionResourceFailedToSetupListCxtFail /* may be nil */, cause /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerInitialContextSetupRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var oldAMF *ngapType.AMFName
	var uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate
	var coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation
	var gUAMI *ngapType.GUAMI
	var pDUSessionResourceSetupListCxtReq *ngapType.PDUSessionResourceSetupListCxtReq
	var allowedNSSAI *ngapType.AllowedNSSAI
	var uESecurityCapabilities *ngapType.UESecurityCapabilities
	var securityKey *ngapType.SecurityKey
	var traceActivation *ngapType.TraceActivation
	var mobilityRestrictionList *ngapType.MobilityRestrictionList
	var uERadioCapability *ngapType.UERadioCapability
	var indexToRFSP *ngapType.IndexToRFSP
	var maskedIMEISV *ngapType.MaskedIMEISV
	var nASPDU *ngapType.NASPDU
	var emergencyFallbackIndicator *ngapType.EmergencyFallbackIndicator
	var rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest
	var uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging
	var redirectionVoiceFallback *ngapType.RedirectionVoiceFallback

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	initialContextSetupRequest := initiatingMessage.Value.InitialContextSetupRequest
	if initialContextSetupRequest == nil {
		ran.Log.Error("InitialContextSetupRequest is nil")
		return
	}

	ran.Log.Info("Handle InitialContextSetupRequest")

	for _, ie := range initialContextSetupRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDOldAMF: // optional, reject
			if oldAMF != nil {
				ran.Log.Error("Duplicate IE AMFName")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			oldAMF = ie.Value.OldAMF
			ran.Log.Trace("Decode IE AMFName")
		case ngapType.ProtocolIEIDUEAggregateMaximumBitRate: // conditional, reject
			if uEAggregateMaximumBitRate != nil {
				ran.Log.Error("Duplicate IE UEAggregateMaximumBitRate")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEAggregateMaximumBitRate = ie.Value.UEAggregateMaximumBitRate
			ran.Log.Trace("Decode IE UEAggregateMaximumBitRate")
		case ngapType.ProtocolIEIDCoreNetworkAssistanceInformation: // optional, ignore
			if coreNetworkAssistanceInformation != nil {
				ran.Log.Error("Duplicate IE CoreNetworkAssistanceInformationForInactive")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			coreNetworkAssistanceInformation = ie.Value.CoreNetworkAssistanceInformation
			ran.Log.Trace("Decode IE CoreNetworkAssistanceInformationForInactive")
		case ngapType.ProtocolIEIDGUAMI: // mandatory, reject
			if gUAMI != nil {
				ran.Log.Error("Duplicate IE GUAMI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			gUAMI = ie.Value.GUAMI
			ran.Log.Trace("Decode IE GUAMI")
		case ngapType.ProtocolIEIDPDUSessionResourceSetupListCxtReq: // optional, reject
			if pDUSessionResourceSetupListCxtReq != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSetupListCxtReq")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceSetupListCxtReq = ie.Value.PDUSessionResourceSetupListCxtReq
			ran.Log.Trace("Decode IE PDUSessionResourceSetupListCxtReq")
		case ngapType.ProtocolIEIDAllowedNSSAI: // mandatory, reject
			if allowedNSSAI != nil {
				ran.Log.Error("Duplicate IE AllowedNSSAI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			allowedNSSAI = ie.Value.AllowedNSSAI
			ran.Log.Trace("Decode IE AllowedNSSAI")
		case ngapType.ProtocolIEIDUESecurityCapabilities: // mandatory, reject
			if uESecurityCapabilities != nil {
				ran.Log.Error("Duplicate IE UESecurityCapabilities")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uESecurityCapabilities = ie.Value.UESecurityCapabilities
			ran.Log.Trace("Decode IE UESecurityCapabilities")
		case ngapType.ProtocolIEIDSecurityKey: // mandatory, reject
			if securityKey != nil {
				ran.Log.Error("Duplicate IE SecurityKey")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			securityKey = ie.Value.SecurityKey
			ran.Log.Trace("Decode IE SecurityKey")
		case ngapType.ProtocolIEIDTraceActivation: // optional, ignore
			if traceActivation != nil {
				ran.Log.Error("Duplicate IE TraceActivation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			traceActivation = ie.Value.TraceActivation
			ran.Log.Trace("Decode IE TraceActivation")
		case ngapType.ProtocolIEIDMobilityRestrictionList: // optional, ignore
			if mobilityRestrictionList != nil {
				ran.Log.Error("Duplicate IE MobilityRestrictionList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			mobilityRestrictionList = ie.Value.MobilityRestrictionList
			ran.Log.Trace("Decode IE MobilityRestrictionList")
		case ngapType.ProtocolIEIDUERadioCapability: // optional, ignore
			if uERadioCapability != nil {
				ran.Log.Error("Duplicate IE UERadioCapability")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERadioCapability = ie.Value.UERadioCapability
			ran.Log.Trace("Decode IE UERadioCapability")
		case ngapType.ProtocolIEIDIndexToRFSP: // optional, ignore
			if indexToRFSP != nil {
				ran.Log.Error("Duplicate IE IndexToRFSP")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			indexToRFSP = ie.Value.IndexToRFSP
			ran.Log.Trace("Decode IE IndexToRFSP")
		case ngapType.ProtocolIEIDMaskedIMEISV: // optional, ignore
			if maskedIMEISV != nil {
				ran.Log.Error("Duplicate IE MaskedIMEISV")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			maskedIMEISV = ie.Value.MaskedIMEISV
			ran.Log.Trace("Decode IE MaskedIMEISV")
		case ngapType.ProtocolIEIDNASPDU: // optional, ignore
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDEmergencyFallbackIndicator: // optional, reject
			if emergencyFallbackIndicator != nil {
				ran.Log.Error("Duplicate IE EmergencyFallbackIndicator")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			emergencyFallbackIndicator = ie.Value.EmergencyFallbackIndicator
			ran.Log.Trace("Decode IE EmergencyFallbackIndicator")
		case ngapType.ProtocolIEIDRRCInactiveTransitionReportRequest: // optional, ignore
			if rRCInactiveTransitionReportRequest != nil {
				ran.Log.Error("Duplicate IE RRCInactiveTransitionReportRequest")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rRCInactiveTransitionReportRequest = ie.Value.RRCInactiveTransitionReportRequest
			ran.Log.Trace("Decode IE RRCInactiveTransitionReportRequest")
		case ngapType.ProtocolIEIDUERadioCapabilityForPaging: // optional, ignore
			if uERadioCapabilityForPaging != nil {
				ran.Log.Error("Duplicate IE UERadioCapabilityForPaging")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERadioCapabilityForPaging = ie.Value.UERadioCapabilityForPaging
			ran.Log.Trace("Decode IE UERadioCapabilityForPaging")
		case ngapType.ProtocolIEIDRedirectionVoiceFallback: // optional, ignore
			if redirectionVoiceFallback != nil {
				ran.Log.Error("Duplicate IE RedirectionVoiceFallback")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			redirectionVoiceFallback = ie.Value.RedirectionVoiceFallback
			ran.Log.Trace("Decode IE RedirectionVoiceFallback")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if gUAMI == nil {
		ran.Log.Error("Missing IE GUAMI")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDGUAMI, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if allowedNSSAI == nil {
		ran.Log.Error("Missing IE AllowedNSSAI")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAllowedNSSAI, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if uESecurityCapabilities == nil {
		ran.Log.Error("Missing IE UESecurityCapabilities")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDUESecurityCapabilities, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if securityKey == nil {
		ran.Log.Error("Missing IE SecurityKey")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSecurityKey, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeInitialContextSetup
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if gUAMI == nil {
		ran.Log.Error("Missing IE GUAMI")
		return
	}
	if allowedNSSAI == nil {
		ran.Log.Error("Missing IE AllowedNSSAI")
		return
	}
	if uESecurityCapabilities == nil {
		ran.Log.Error("Missing IE UESecurityCapabilities")
		return
	}
	if securityKey == nil {
		ran.Log.Error("Missing IE SecurityKey")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle InitialContextSetupRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle InitialContextSetupRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle InitialContextSetupRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleInitialContextSetupRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	oldAMF *ngapType.AMFName,
	//	uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate,
	//	coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation,
	//	gUAMI *ngapType.GUAMI,
	//	pDUSessionResourceSetupListCxtReq *ngapType.PDUSessionResourceSetupListCxtReq,
	//	allowedNSSAI *ngapType.AllowedNSSAI,
	//	uESecurityCapabilities *ngapType.UESecurityCapabilities,
	//	securityKey *ngapType.SecurityKey,
	//	traceActivation *ngapType.TraceActivation,
	//	mobilityRestrictionList *ngapType.MobilityRestrictionList,
	//	uERadioCapability *ngapType.UERadioCapability,
	//	indexToRFSP *ngapType.IndexToRFSP,
	//	maskedIMEISV *ngapType.MaskedIMEISV,
	//	nASPDU *ngapType.NASPDU,
	//	emergencyFallbackIndicator *ngapType.EmergencyFallbackIndicator,
	//	rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest,
	//	uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging,
	//	redirectionVoiceFallback *ngapType.RedirectionVoiceFallback) {
	handleInitialContextSetupRequestMain(ran, ranUe, oldAMF /* may be nil */, uEAggregateMaximumBitRate /* may be nil */, coreNetworkAssistanceInformation /* may be nil */, gUAMI, pDUSessionResourceSetupListCxtReq /* may be nil */, allowedNSSAI, uESecurityCapabilities, securityKey, traceActivation /* may be nil */, mobilityRestrictionList /* may be nil */, uERadioCapability /* may be nil */, indexToRFSP /* may be nil */, maskedIMEISV /* may be nil */, nASPDU /* may be nil */, emergencyFallbackIndicator /* may be nil */, rRCInactiveTransitionReportRequest /* may be nil */, uERadioCapabilityForPaging /* may be nil */, redirectionVoiceFallback /* may be nil */)
}

func handleInitialContextSetupRequestMain(ran *context.AmfRan, ranUe *context.RanUe, oldAMF *ngapType.AMFName, uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate, coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation, gUAMI *ngapType.GUAMI, pDUSessionResourceSetupListCxtReq *ngapType.PDUSessionResourceSetupListCxtReq, allowedNSSAI *ngapType.AllowedNSSAI, uESecurityCapabilities *ngapType.UESecurityCapabilities, securityKey *ngapType.SecurityKey, traceActivation *ngapType.TraceActivation, mobilityRestrictionList *ngapType.MobilityRestrictionList, uERadioCapability *ngapType.UERadioCapability, indexToRFSP *ngapType.IndexToRFSP, maskedIMEISV *ngapType.MaskedIMEISV, nASPDU *ngapType.NASPDU, emergencyFallbackIndicator *ngapType.EmergencyFallbackIndicator, rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest, uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging, redirectionVoiceFallback *ngapType.RedirectionVoiceFallback) {
	ran.Log.Error("Handle InitialContextSetupRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeInitialContextSetup
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerInitialContextSetupResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceSetupListCxtRes *ngapType.PDUSessionResourceSetupListCxtRes
	var pDUSessionResourceFailedToSetupListCxtRes *ngapType.PDUSessionResourceFailedToSetupListCxtRes
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	initialContextSetupResponse := successfulOutcome.Value.InitialContextSetupResponse
	if initialContextSetupResponse == nil {
		ran.Log.Error("InitialContextSetupResponse is nil")
		return
	}

	ran.Log.Info("Handle InitialContextSetupResponse")

	for _, ie := range initialContextSetupResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceSetupListCxtRes: // optional, ignore
			if pDUSessionResourceSetupListCxtRes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSetupListCxtRes")
				abort = true
				break
			}
			pDUSessionResourceSetupListCxtRes = ie.Value.PDUSessionResourceSetupListCxtRes
			ran.Log.Trace("Decode IE PDUSessionResourceSetupListCxtRes")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToSetupListCxtRes: // optional, ignore
			if pDUSessionResourceFailedToSetupListCxtRes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToSetupListCxtRes")
				abort = true
				break
			}
			pDUSessionResourceFailedToSetupListCxtRes = ie.Value.PDUSessionResourceFailedToSetupListCxtRes
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToSetupListCxtRes")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeInitialContextSetup
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle InitialContextSetupResponse: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle InitialContextSetupResponse: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle InitialContextSetupResponse (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleInitialContextSetupResponseMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceSetupListCxtRes *ngapType.PDUSessionResourceSetupListCxtRes,
	//	pDUSessionResourceFailedToSetupListCxtRes *ngapType.PDUSessionResourceFailedToSetupListCxtRes,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleInitialContextSetupResponseMain(ran, ranUe /* may be nil */, pDUSessionResourceSetupListCxtRes /* may be nil */, pDUSessionResourceFailedToSetupListCxtRes /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerInitialUEMessage(ran *context.AmfRan, message *ngapType.NGAPPDU, initiatingMessage *ngapType.InitiatingMessage) {
	var rANUENGAPID *ngapType.RANUENGAPID
	var nASPDU *ngapType.NASPDU
	var userLocationInformation *ngapType.UserLocationInformation
	var rRCEstablishmentCause *ngapType.RRCEstablishmentCause
	var fiveGSTMSI *ngapType.FiveGSTMSI
	var aMFSetID *ngapType.AMFSetID
	var uEContextRequest *ngapType.UEContextRequest
	var allowedNSSAI *ngapType.AllowedNSSAI

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	initialUEMessage := initiatingMessage.Value.InitialUEMessage
	if initialUEMessage == nil {
		ran.Log.Error("InitialUEMessage is nil")
		return
	}

	ran.Log.Info("Handle InitialUEMessage")

	for _, ie := range initialUEMessage.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDNASPDU: // mandatory, reject
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDUserLocationInformation: // mandatory, reject
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDRRCEstablishmentCause: // mandatory, ignore
			if rRCEstablishmentCause != nil {
				ran.Log.Error("Duplicate IE RRCEstablishmentCause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rRCEstablishmentCause = ie.Value.RRCEstablishmentCause
			ran.Log.Trace("Decode IE RRCEstablishmentCause")
		case ngapType.ProtocolIEIDFiveGSTMSI: // optional, reject
			if fiveGSTMSI != nil {
				ran.Log.Error("Duplicate IE FiveG-S-TMSI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			fiveGSTMSI = ie.Value.FiveGSTMSI
			ran.Log.Trace("Decode IE FiveG-S-TMSI")
		case ngapType.ProtocolIEIDAMFSetID: // optional, ignore
			if aMFSetID != nil {
				ran.Log.Error("Duplicate IE AMFSetID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFSetID = ie.Value.AMFSetID
			ran.Log.Trace("Decode IE AMFSetID")
		case ngapType.ProtocolIEIDUEContextRequest: // optional, ignore
			if uEContextRequest != nil {
				ran.Log.Error("Duplicate IE UEContextRequest")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEContextRequest = ie.Value.UEContextRequest
			ran.Log.Trace("Decode IE UEContextRequest")
		case ngapType.ProtocolIEIDAllowedNSSAI: // optional, reject
			if allowedNSSAI != nil {
				ran.Log.Error("Duplicate IE AllowedNSSAI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			allowedNSSAI = ie.Value.AllowedNSSAI
			ran.Log.Trace("Decode IE AllowedNSSAI")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nASPDU == nil {
		ran.Log.Error("Missing IE NAS-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNASPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if userLocationInformation == nil {
		ran.Log.Error("Missing IE UserLocationInformation")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDUserLocationInformation, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeInitialUEMessage
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nASPDU == nil {
		ran.Log.Error("Missing IE NAS-PDU")
		return
	}
	if userLocationInformation == nil {
		ran.Log.Error("Missing IE UserLocationInformation")
		return
	}
	if rRCEstablishmentCause == nil {
		ran.Log.Warn("Missing IE RRCEstablishmentCause")
	}
	if aMFSetID != nil {
		ran.Log.Warn("IE AMFSetID is not implemented")
	}
	if allowedNSSAI != nil {
		ran.Log.Warn("IE AllowedNSSAI is not implemented")
	}

	// func handleInitialUEMessageMain(ran *context.AmfRan,
	//	message *ngapType.NGAPPDU,
	//	rANUENGAPID *ngapType.RANUENGAPID,
	//	nASPDU *ngapType.NASPDU,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	rRCEstablishmentCause *ngapType.RRCEstablishmentCause,
	//	fiveGSTMSI *ngapType.FiveGSTMSI,
	//	uEContextRequest *ngapType.UEContextRequest) {
	handleInitialUEMessageMain(ran, message, rANUENGAPID, nASPDU, userLocationInformation, rRCEstablishmentCause /* may be nil */, fiveGSTMSI /* may be nil */, uEContextRequest /* may be nil */)
}

func handlerLocationReport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var userLocationInformation *ngapType.UserLocationInformation
	var uEPresenceInAreaOfInterestList *ngapType.UEPresenceInAreaOfInterestList
	var locationReportingRequestType *ngapType.LocationReportingRequestType

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	locationReport := initiatingMessage.Value.LocationReport
	if locationReport == nil {
		ran.Log.Error("LocationReport is nil")
		return
	}

	ran.Log.Info("Handle LocationReport")

	for _, ie := range locationReport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUserLocationInformation: // mandatory, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDUEPresenceInAreaOfInterestList: // optional, ignore
			if uEPresenceInAreaOfInterestList != nil {
				ran.Log.Error("Duplicate IE UEPresenceInAreaOfInterestList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEPresenceInAreaOfInterestList = ie.Value.UEPresenceInAreaOfInterestList
			ran.Log.Trace("Decode IE UEPresenceInAreaOfInterestList")
		case ngapType.ProtocolIEIDLocationReportingRequestType: // mandatory, ignore
			if locationReportingRequestType != nil {
				ran.Log.Error("Duplicate IE LocationReportingRequestType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			locationReportingRequestType = ie.Value.LocationReportingRequestType
			ran.Log.Trace("Decode IE LocationReportingRequestType")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeLocationReport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if userLocationInformation == nil {
		ran.Log.Warn("Missing IE UserLocationInformation")
	}
	if locationReportingRequestType == nil {
		ran.Log.Warn("Missing IE LocationReportingRequestType")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle LocationReport: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle LocationReport: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle LocationReport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleLocationReportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	uEPresenceInAreaOfInterestList *ngapType.UEPresenceInAreaOfInterestList,
	//	locationReportingRequestType *ngapType.LocationReportingRequestType) {
	handleLocationReportMain(ran, ranUe, userLocationInformation /* may be nil */, uEPresenceInAreaOfInterestList /* may be nil */, locationReportingRequestType /* may be nil */)
}

func handlerLocationReportingControl(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var locationReportingRequestType *ngapType.LocationReportingRequestType

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	locationReportingControl := initiatingMessage.Value.LocationReportingControl
	if locationReportingControl == nil {
		ran.Log.Error("LocationReportingControl is nil")
		return
	}

	ran.Log.Info("Handle LocationReportingControl")

	for _, ie := range locationReportingControl.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDLocationReportingRequestType: // mandatory, ignore
			if locationReportingRequestType != nil {
				ran.Log.Error("Duplicate IE LocationReportingRequestType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			locationReportingRequestType = ie.Value.LocationReportingRequestType
			ran.Log.Trace("Decode IE LocationReportingRequestType")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeLocationReportingControl
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if locationReportingRequestType == nil {
		ran.Log.Warn("Missing IE LocationReportingRequestType")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle LocationReportingControl: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle LocationReportingControl: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle LocationReportingControl (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleLocationReportingControlMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	locationReportingRequestType *ngapType.LocationReportingRequestType) {
	handleLocationReportingControlMain(ran, ranUe, locationReportingRequestType /* may be nil */)
}

func handleLocationReportingControlMain(ran *context.AmfRan, ranUe *context.RanUe, locationReportingRequestType *ngapType.LocationReportingRequestType) {
	ran.Log.Error("Handle LocationReportingControl: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeLocationReportingControl
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerLocationReportingFailureIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var cause *ngapType.Cause

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	locationReportingFailureIndication := initiatingMessage.Value.LocationReportingFailureIndication
	if locationReportingFailureIndication == nil {
		ran.Log.Error("LocationReportingFailureIndication is nil")
		return
	}

	ran.Log.Info("Handle LocationReportingFailureIndication")

	for _, ie := range locationReportingFailureIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeLocationReportingFailureIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle LocationReportingFailureIndication: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle LocationReportingFailureIndication: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle LocationReportingFailureIndication (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleLocationReportingFailureIndicationMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	cause *ngapType.Cause) {
	handleLocationReportingFailureIndicationMain(ran, ranUe, cause /* may be nil */)
}

func handlerNASNonDeliveryIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var nASPDU *ngapType.NASPDU
	var cause *ngapType.Cause

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	nASNonDeliveryIndication := initiatingMessage.Value.NASNonDeliveryIndication
	if nASNonDeliveryIndication == nil {
		ran.Log.Error("NASNonDeliveryIndication is nil")
		return
	}

	ran.Log.Info("Handle NASNonDeliveryIndication")

	for _, ie := range nASNonDeliveryIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDNASPDU: // mandatory, ignore
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeNASNonDeliveryIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nASPDU == nil {
		ran.Log.Warn("Missing IE NAS-PDU")
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle NASNonDeliveryIndication: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle NASNonDeliveryIndication: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle NASNonDeliveryIndication (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleNASNonDeliveryIndicationMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	nASPDU *ngapType.NASPDU,
	//	cause *ngapType.Cause) {
	handleNASNonDeliveryIndicationMain(ran, ranUe, nASPDU /* may be nil */, cause /* may be nil */)
}

func handlerNGReset(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var cause *ngapType.Cause
	var resetType *ngapType.ResetType

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	nGReset := initiatingMessage.Value.NGReset
	if nGReset == nil {
		ran.Log.Error("NGReset is nil")
		return
	}

	ran.Log.Info("Handle NGReset")

	for _, ie := range nGReset.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDResetType: // mandatory, reject
			if resetType != nil {
				ran.Log.Error("Duplicate IE ResetType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			resetType = ie.Value.ResetType
			ran.Log.Trace("Decode IE ResetType")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if resetType == nil {
		ran.Log.Error("Missing IE ResetType")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDResetType, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeNGReset
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}
	if resetType == nil {
		ran.Log.Error("Missing IE ResetType")
		return
	}

	// func handleNGResetMain(ran *context.AmfRan,
	//	cause *ngapType.Cause,
	//	resetType *ngapType.ResetType) {
	handleNGResetMain(ran, cause /* may be nil */, resetType)
}

func handlerNGResetAcknowledge(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var uEAssociatedLogicalNGConnectionList *ngapType.UEAssociatedLogicalNGConnectionList
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	nGResetAcknowledge := successfulOutcome.Value.NGResetAcknowledge
	if nGResetAcknowledge == nil {
		ran.Log.Error("NGResetAcknowledge is nil")
		return
	}

	ran.Log.Info("Handle NGResetAcknowledge")

	for _, ie := range nGResetAcknowledge.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDUEAssociatedLogicalNGConnectionList: // optional, ignore
			if uEAssociatedLogicalNGConnectionList != nil {
				ran.Log.Error("Duplicate IE UE-associatedLogicalNG-connectionList")
				abort = true
				break
			}
			uEAssociatedLogicalNGConnectionList = ie.Value.UEAssociatedLogicalNGConnectionList
			ran.Log.Trace("Decode IE UE-associatedLogicalNG-connectionList")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeNGReset
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleNGResetAcknowledgeMain(ran *context.AmfRan,
	//	uEAssociatedLogicalNGConnectionList *ngapType.UEAssociatedLogicalNGConnectionList,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleNGResetAcknowledgeMain(ran, uEAssociatedLogicalNGConnectionList /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerNGSetupFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var cause *ngapType.Cause
	var timeToWait *ngapType.TimeToWait
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	nGSetupFailure := unsuccessfulOutcome.Value.NGSetupFailure
	if nGSetupFailure == nil {
		ran.Log.Error("NGSetupFailure is nil")
		return
	}

	ran.Log.Info("Handle NGSetupFailure")

	for _, ie := range nGSetupFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDTimeToWait: // optional, ignore
			if timeToWait != nil {
				ran.Log.Error("Duplicate IE TimeToWait")
				abort = true
				break
			}
			timeToWait = ie.Value.TimeToWait
			ran.Log.Trace("Decode IE TimeToWait")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeNGSetup
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// func handleNGSetupFailureMain(ran *context.AmfRan,
	//	cause *ngapType.Cause,
	//	timeToWait *ngapType.TimeToWait,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleNGSetupFailureMain(ran, cause /* may be nil */, timeToWait /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handleNGSetupFailureMain(ran *context.AmfRan, cause *ngapType.Cause, timeToWait *ngapType.TimeToWait, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle NGSetupFailure: AMF to RAN message")
}

func handlerNGSetupRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var globalRANNodeID *ngapType.GlobalRANNodeID
	var rANNodeName *ngapType.RANNodeName
	var supportedTAList *ngapType.SupportedTAList
	var defaultPagingDRX *ngapType.PagingDRX
	var uERetentionInformation *ngapType.UERetentionInformation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	nGSetupRequest := initiatingMessage.Value.NGSetupRequest
	if nGSetupRequest == nil {
		ran.Log.Error("NGSetupRequest is nil")
		return
	}

	ran.Log.Info("Handle NGSetupRequest")

	for _, ie := range nGSetupRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDGlobalRANNodeID: // mandatory, reject
			if globalRANNodeID != nil {
				ran.Log.Error("Duplicate IE GlobalRANNodeID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			globalRANNodeID = ie.Value.GlobalRANNodeID
			ran.Log.Trace("Decode IE GlobalRANNodeID")
		case ngapType.ProtocolIEIDRANNodeName: // optional, ignore
			if rANNodeName != nil {
				ran.Log.Error("Duplicate IE RANNodeName")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANNodeName = ie.Value.RANNodeName
			ran.Log.Trace("Decode IE RANNodeName")
		case ngapType.ProtocolIEIDSupportedTAList: // mandatory, reject
			if supportedTAList != nil {
				ran.Log.Error("Duplicate IE SupportedTAList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			supportedTAList = ie.Value.SupportedTAList
			ran.Log.Trace("Decode IE SupportedTAList")
		case ngapType.ProtocolIEIDDefaultPagingDRX: // mandatory, ignore
			if defaultPagingDRX != nil {
				ran.Log.Error("Duplicate IE PagingDRX")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			defaultPagingDRX = ie.Value.DefaultPagingDRX
			ran.Log.Trace("Decode IE PagingDRX")
		case ngapType.ProtocolIEIDUERetentionInformation: // optional, ignore
			if uERetentionInformation != nil {
				ran.Log.Error("Duplicate IE UERetentionInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERetentionInformation = ie.Value.UERetentionInformation
			ran.Log.Trace("Decode IE UERetentionInformation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if globalRANNodeID == nil {
		ran.Log.Error("Missing IE GlobalRANNodeID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDGlobalRANNodeID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if supportedTAList == nil {
		ran.Log.Error("Missing IE SupportedTAList")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSupportedTAList, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeNGSetup
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		if syntaxCause == nil {
			syntaxCause = &ngapType.Cause{
				Present: ngapType.CausePresentProtocol,
				Protocol: &ngapType.CauseProtocol{
					Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
				},
			}
		}
		rawSendNGSetupFailure(ran, *syntaxCause, nil, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if globalRANNodeID == nil {
		ran.Log.Error("Missing IE GlobalRANNodeID")
		return
	}
	if supportedTAList == nil {
		ran.Log.Error("Missing IE SupportedTAList")
		return
	}
	if defaultPagingDRX == nil {
		ran.Log.Warn("Missing IE PagingDRX")
	}
	if uERetentionInformation != nil {
		ran.Log.Warn("IE UERetentionInformation is not implemented")
	}

	// func handleNGSetupRequestMain(ran *context.AmfRan,
	//	globalRANNodeID *ngapType.GlobalRANNodeID,
	//	rANNodeName *ngapType.RANNodeName,
	//	supportedTAList *ngapType.SupportedTAList,
	//	defaultPagingDRX *ngapType.PagingDRX) {
	handleNGSetupRequestMain(ran, globalRANNodeID, rANNodeName /* may be nil */, supportedTAList, defaultPagingDRX /* may be nil */)
}

func handlerNGSetupResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFName *ngapType.AMFName
	var servedGUAMIList *ngapType.ServedGUAMIList
	var relativeAMFCapacity *ngapType.RelativeAMFCapacity
	var pLMNSupportList *ngapType.PLMNSupportList
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics
	var uERetentionInformation *ngapType.UERetentionInformation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	nGSetupResponse := successfulOutcome.Value.NGSetupResponse
	if nGSetupResponse == nil {
		ran.Log.Error("NGSetupResponse is nil")
		return
	}

	ran.Log.Info("Handle NGSetupResponse")

	for _, ie := range nGSetupResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFName: // mandatory, reject
			if aMFName != nil {
				ran.Log.Error("Duplicate IE AMFName")
				abort = true
				break
			}
			aMFName = ie.Value.AMFName
			ran.Log.Trace("Decode IE AMFName")
		case ngapType.ProtocolIEIDServedGUAMIList: // mandatory, reject
			if servedGUAMIList != nil {
				ran.Log.Error("Duplicate IE ServedGUAMIList")
				abort = true
				break
			}
			servedGUAMIList = ie.Value.ServedGUAMIList
			ran.Log.Trace("Decode IE ServedGUAMIList")
		case ngapType.ProtocolIEIDRelativeAMFCapacity: // mandatory, ignore
			if relativeAMFCapacity != nil {
				ran.Log.Error("Duplicate IE RelativeAMFCapacity")
				abort = true
				break
			}
			relativeAMFCapacity = ie.Value.RelativeAMFCapacity
			ran.Log.Trace("Decode IE RelativeAMFCapacity")
		case ngapType.ProtocolIEIDPLMNSupportList: // mandatory, reject
			if pLMNSupportList != nil {
				ran.Log.Error("Duplicate IE PLMNSupportList")
				abort = true
				break
			}
			pLMNSupportList = ie.Value.PLMNSupportList
			ran.Log.Trace("Decode IE PLMNSupportList")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		case ngapType.ProtocolIEIDUERetentionInformation: // optional, ignore
			if uERetentionInformation != nil {
				ran.Log.Error("Duplicate IE UERetentionInformation")
				abort = true
				break
			}
			uERetentionInformation = ie.Value.UERetentionInformation
			ran.Log.Trace("Decode IE UERetentionInformation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeNGSetup
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFName == nil {
		ran.Log.Error("Missing IE AMFName")
		return
	}
	if servedGUAMIList == nil {
		ran.Log.Error("Missing IE ServedGUAMIList")
		return
	}
	if relativeAMFCapacity == nil {
		ran.Log.Warn("Missing IE RelativeAMFCapacity")
	}
	if pLMNSupportList == nil {
		ran.Log.Error("Missing IE PLMNSupportList")
		return
	}

	// func handleNGSetupResponseMain(ran *context.AmfRan,
	//	aMFName *ngapType.AMFName,
	//	servedGUAMIList *ngapType.ServedGUAMIList,
	//	relativeAMFCapacity *ngapType.RelativeAMFCapacity,
	//	pLMNSupportList *ngapType.PLMNSupportList,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics,
	//	uERetentionInformation *ngapType.UERetentionInformation) {
	handleNGSetupResponseMain(ran, aMFName, servedGUAMIList, relativeAMFCapacity /* may be nil */, pLMNSupportList, criticalityDiagnostics /* may be nil */, uERetentionInformation /* may be nil */)
}

func handleNGSetupResponseMain(ran *context.AmfRan, aMFName *ngapType.AMFName, servedGUAMIList *ngapType.ServedGUAMIList, relativeAMFCapacity *ngapType.RelativeAMFCapacity, pLMNSupportList *ngapType.PLMNSupportList, criticalityDiagnostics *ngapType.CriticalityDiagnostics, uERetentionInformation *ngapType.UERetentionInformation) {
	ran.Log.Error("Handle NGSetupResponse: AMF to RAN message")
}

func handlerOverloadStart(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFOverloadResponse *ngapType.OverloadResponse
	var aMFTrafficLoadReductionIndication *ngapType.TrafficLoadReductionIndication
	var overloadStartNSSAIList *ngapType.OverloadStartNSSAIList

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	overloadStart := initiatingMessage.Value.OverloadStart
	if overloadStart == nil {
		ran.Log.Error("OverloadStart is nil")
		return
	}

	ran.Log.Info("Handle OverloadStart")

	for _, ie := range overloadStart.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFOverloadResponse: // optional, reject
			if aMFOverloadResponse != nil {
				ran.Log.Error("Duplicate IE OverloadResponse")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFOverloadResponse = ie.Value.AMFOverloadResponse
			ran.Log.Trace("Decode IE OverloadResponse")
		case ngapType.ProtocolIEIDAMFTrafficLoadReductionIndication: // optional, ignore
			if aMFTrafficLoadReductionIndication != nil {
				ran.Log.Error("Duplicate IE TrafficLoadReductionIndication")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFTrafficLoadReductionIndication = ie.Value.AMFTrafficLoadReductionIndication
			ran.Log.Trace("Decode IE TrafficLoadReductionIndication")
		case ngapType.ProtocolIEIDOverloadStartNSSAIList: // optional, ignore
			if overloadStartNSSAIList != nil {
				ran.Log.Error("Duplicate IE OverloadStartNSSAIList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			overloadStartNSSAIList = ie.Value.OverloadStartNSSAIList
			ran.Log.Trace("Decode IE OverloadStartNSSAIList")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeOverloadStart
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleOverloadStartMain(ran *context.AmfRan,
	//	aMFOverloadResponse *ngapType.OverloadResponse,
	//	aMFTrafficLoadReductionIndication *ngapType.TrafficLoadReductionIndication,
	//	overloadStartNSSAIList *ngapType.OverloadStartNSSAIList) {
	handleOverloadStartMain(ran, aMFOverloadResponse /* may be nil */, aMFTrafficLoadReductionIndication /* may be nil */, overloadStartNSSAIList /* may be nil */)
}

func handleOverloadStartMain(ran *context.AmfRan, aMFOverloadResponse *ngapType.OverloadResponse, aMFTrafficLoadReductionIndication *ngapType.TrafficLoadReductionIndication, overloadStartNSSAIList *ngapType.OverloadStartNSSAIList) {
	ran.Log.Error("Handle OverloadStart: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeOverloadStart
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerOverloadStop(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	overloadStop := initiatingMessage.Value.OverloadStop
	if overloadStop == nil {
		ran.Log.Error("OverloadStop is nil")
		return
	}

	ran.Log.Info("Handle OverloadStop")

	for _, ie := range overloadStop.ProtocolIEs.List {
		switch ie.Id.Value {
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeOverloadStop
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleOverloadStopMain(ran *context.AmfRan) {
	handleOverloadStopMain(ran)
}

func handleOverloadStopMain(ran *context.AmfRan) {
	ran.Log.Error("Handle OverloadStop: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeOverloadStop
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPDUSessionResourceModifyConfirm(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceModifyListModCfm *ngapType.PDUSessionResourceModifyListModCfm
	var pDUSessionResourceFailedToModifyListModCfm *ngapType.PDUSessionResourceFailedToModifyListModCfm
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceModifyConfirm := successfulOutcome.Value.PDUSessionResourceModifyConfirm
	if pDUSessionResourceModifyConfirm == nil {
		ran.Log.Error("PDUSessionResourceModifyConfirm is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceModifyConfirm")

	for _, ie := range pDUSessionResourceModifyConfirm.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceModifyListModCfm: // optional, ignore
			if pDUSessionResourceModifyListModCfm != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceModifyListModCfm")
				abort = true
				break
			}
			pDUSessionResourceModifyListModCfm = ie.Value.PDUSessionResourceModifyListModCfm
			ran.Log.Trace("Decode IE PDUSessionResourceModifyListModCfm")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToModifyListModCfm: // optional, ignore
			if pDUSessionResourceFailedToModifyListModCfm != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToModifyListModCfm")
				abort = true
				break
			}
			pDUSessionResourceFailedToModifyListModCfm = ie.Value.PDUSessionResourceFailedToModifyListModCfm
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToModifyListModCfm")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceModifyIndication
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle PDUSessionResourceModifyConfirm: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle PDUSessionResourceModifyConfirm: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle PDUSessionResourceModifyConfirm (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handlePDUSessionResourceModifyConfirmMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceModifyListModCfm *ngapType.PDUSessionResourceModifyListModCfm,
	//	pDUSessionResourceFailedToModifyListModCfm *ngapType.PDUSessionResourceFailedToModifyListModCfm,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handlePDUSessionResourceModifyConfirmMain(ran, ranUe /* may be nil */, pDUSessionResourceModifyListModCfm /* may be nil */, pDUSessionResourceFailedToModifyListModCfm /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlePDUSessionResourceModifyConfirmMain(ran *context.AmfRan, ranUe *context.RanUe, pDUSessionResourceModifyListModCfm *ngapType.PDUSessionResourceModifyListModCfm, pDUSessionResourceFailedToModifyListModCfm *ngapType.PDUSessionResourceFailedToModifyListModCfm, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle PDUSessionResourceModifyConfirm: AMF to RAN message")
}

func handlerPDUSessionResourceModifyIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceModifyListModInd *ngapType.PDUSessionResourceModifyListModInd

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceModifyIndication := initiatingMessage.Value.PDUSessionResourceModifyIndication
	if pDUSessionResourceModifyIndication == nil {
		ran.Log.Error("PDUSessionResourceModifyIndication is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceModifyIndication")

	for _, ie := range pDUSessionResourceModifyIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceModifyListModInd: // mandatory, reject
			if pDUSessionResourceModifyListModInd != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceModifyListModInd")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceModifyListModInd = ie.Value.PDUSessionResourceModifyListModInd
			ran.Log.Trace("Decode IE PDUSessionResourceModifyListModInd")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceModifyListModInd == nil {
		ran.Log.Error("Missing IE PDUSessionResourceModifyListModInd")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceModifyListModInd, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceModifyIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if pDUSessionResourceModifyListModInd == nil {
		ran.Log.Error("Missing IE PDUSessionResourceModifyListModInd")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle PDUSessionResourceModifyIndication: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle PDUSessionResourceModifyIndication: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle PDUSessionResourceModifyIndication (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handlePDUSessionResourceModifyIndicationMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceModifyListModInd *ngapType.PDUSessionResourceModifyListModInd) {
	handlePDUSessionResourceModifyIndicationMain(ran, ranUe, pDUSessionResourceModifyListModInd)
}

func handlerPDUSessionResourceModifyRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rANPagingPriority *ngapType.RANPagingPriority
	var pDUSessionResourceModifyListModReq *ngapType.PDUSessionResourceModifyListModReq

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceModifyRequest := initiatingMessage.Value.PDUSessionResourceModifyRequest
	if pDUSessionResourceModifyRequest == nil {
		ran.Log.Error("PDUSessionResourceModifyRequest is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceModifyRequest")

	for _, ie := range pDUSessionResourceModifyRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANPagingPriority: // optional, ignore
			if rANPagingPriority != nil {
				ran.Log.Error("Duplicate IE RANPagingPriority")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANPagingPriority = ie.Value.RANPagingPriority
			ran.Log.Trace("Decode IE RANPagingPriority")
		case ngapType.ProtocolIEIDPDUSessionResourceModifyListModReq: // mandatory, reject
			if pDUSessionResourceModifyListModReq != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceModifyListModReq")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceModifyListModReq = ie.Value.PDUSessionResourceModifyListModReq
			ran.Log.Trace("Decode IE PDUSessionResourceModifyListModReq")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceModifyListModReq == nil {
		ran.Log.Error("Missing IE PDUSessionResourceModifyListModReq")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceModifyListModReq, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceModify
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if pDUSessionResourceModifyListModReq == nil {
		ran.Log.Error("Missing IE PDUSessionResourceModifyListModReq")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle PDUSessionResourceModifyRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle PDUSessionResourceModifyRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle PDUSessionResourceModifyRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handlePDUSessionResourceModifyRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rANPagingPriority *ngapType.RANPagingPriority,
	//	pDUSessionResourceModifyListModReq *ngapType.PDUSessionResourceModifyListModReq) {
	handlePDUSessionResourceModifyRequestMain(ran, ranUe, rANPagingPriority /* may be nil */, pDUSessionResourceModifyListModReq)
}

func handlePDUSessionResourceModifyRequestMain(ran *context.AmfRan, ranUe *context.RanUe, rANPagingPriority *ngapType.RANPagingPriority, pDUSessionResourceModifyListModReq *ngapType.PDUSessionResourceModifyListModReq) {
	ran.Log.Error("Handle PDUSessionResourceModifyRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodePDUSessionResourceModify
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPDUSessionResourceModifyResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceModifyListModRes *ngapType.PDUSessionResourceModifyListModRes
	var pDUSessionResourceFailedToModifyListModRes *ngapType.PDUSessionResourceFailedToModifyListModRes
	var userLocationInformation *ngapType.UserLocationInformation
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceModifyResponse := successfulOutcome.Value.PDUSessionResourceModifyResponse
	if pDUSessionResourceModifyResponse == nil {
		ran.Log.Error("PDUSessionResourceModifyResponse is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceModifyResponse")

	for _, ie := range pDUSessionResourceModifyResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceModifyListModRes: // optional, ignore
			if pDUSessionResourceModifyListModRes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceModifyListModRes")
				abort = true
				break
			}
			pDUSessionResourceModifyListModRes = ie.Value.PDUSessionResourceModifyListModRes
			ran.Log.Trace("Decode IE PDUSessionResourceModifyListModRes")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToModifyListModRes: // optional, ignore
			if pDUSessionResourceFailedToModifyListModRes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToModifyListModRes")
				abort = true
				break
			}
			pDUSessionResourceFailedToModifyListModRes = ie.Value.PDUSessionResourceFailedToModifyListModRes
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToModifyListModRes")
		case ngapType.ProtocolIEIDUserLocationInformation: // optional, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceModify
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle PDUSessionResourceModifyResponse: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle PDUSessionResourceModifyResponse: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle PDUSessionResourceModifyResponse (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handlePDUSessionResourceModifyResponseMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceModifyListModRes *ngapType.PDUSessionResourceModifyListModRes,
	//	pDUSessionResourceFailedToModifyListModRes *ngapType.PDUSessionResourceFailedToModifyListModRes,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handlePDUSessionResourceModifyResponseMain(ran, ranUe /* may be nil */, pDUSessionResourceModifyListModRes /* may be nil */, pDUSessionResourceFailedToModifyListModRes /* may be nil */, userLocationInformation /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerPDUSessionResourceNotify(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceNotifyList *ngapType.PDUSessionResourceNotifyList
	var pDUSessionResourceReleasedListNot *ngapType.PDUSessionResourceReleasedListNot
	var userLocationInformation *ngapType.UserLocationInformation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceNotify := initiatingMessage.Value.PDUSessionResourceNotify
	if pDUSessionResourceNotify == nil {
		ran.Log.Error("PDUSessionResourceNotify is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceNotify")

	for _, ie := range pDUSessionResourceNotify.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceNotifyList: // optional, reject
			if pDUSessionResourceNotifyList != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceNotifyList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceNotifyList = ie.Value.PDUSessionResourceNotifyList
			ran.Log.Trace("Decode IE PDUSessionResourceNotifyList")
		case ngapType.ProtocolIEIDPDUSessionResourceReleasedListNot: // optional, ignore
			if pDUSessionResourceReleasedListNot != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceReleasedListNot")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceReleasedListNot = ie.Value.PDUSessionResourceReleasedListNot
			ran.Log.Trace("Decode IE PDUSessionResourceReleasedListNot")
		case ngapType.ProtocolIEIDUserLocationInformation: // optional, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceNotify
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle PDUSessionResourceNotify: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle PDUSessionResourceNotify: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle PDUSessionResourceNotify (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handlePDUSessionResourceNotifyMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceNotifyList *ngapType.PDUSessionResourceNotifyList,
	//	pDUSessionResourceReleasedListNot *ngapType.PDUSessionResourceReleasedListNot,
	//	userLocationInformation *ngapType.UserLocationInformation) {
	handlePDUSessionResourceNotifyMain(ran, ranUe, pDUSessionResourceNotifyList /* may be nil */, pDUSessionResourceReleasedListNot /* may be nil */, userLocationInformation /* may be nil */)
}

func handlerPDUSessionResourceReleaseCommand(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rANPagingPriority *ngapType.RANPagingPriority
	var nASPDU *ngapType.NASPDU
	var pDUSessionResourceToReleaseListRelCmd *ngapType.PDUSessionResourceToReleaseListRelCmd

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceReleaseCommand := initiatingMessage.Value.PDUSessionResourceReleaseCommand
	if pDUSessionResourceReleaseCommand == nil {
		ran.Log.Error("PDUSessionResourceReleaseCommand is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceReleaseCommand")

	for _, ie := range pDUSessionResourceReleaseCommand.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANPagingPriority: // optional, ignore
			if rANPagingPriority != nil {
				ran.Log.Error("Duplicate IE RANPagingPriority")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANPagingPriority = ie.Value.RANPagingPriority
			ran.Log.Trace("Decode IE RANPagingPriority")
		case ngapType.ProtocolIEIDNASPDU: // optional, ignore
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDPDUSessionResourceToReleaseListRelCmd: // mandatory, reject
			if pDUSessionResourceToReleaseListRelCmd != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceToReleaseListRelCmd")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceToReleaseListRelCmd = ie.Value.PDUSessionResourceToReleaseListRelCmd
			ran.Log.Trace("Decode IE PDUSessionResourceToReleaseListRelCmd")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceToReleaseListRelCmd == nil {
		ran.Log.Error("Missing IE PDUSessionResourceToReleaseListRelCmd")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceToReleaseListRelCmd, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceRelease
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if pDUSessionResourceToReleaseListRelCmd == nil {
		ran.Log.Error("Missing IE PDUSessionResourceToReleaseListRelCmd")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle PDUSessionResourceReleaseCommand: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle PDUSessionResourceReleaseCommand: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle PDUSessionResourceReleaseCommand (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handlePDUSessionResourceReleaseCommandMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rANPagingPriority *ngapType.RANPagingPriority,
	//	nASPDU *ngapType.NASPDU,
	//	pDUSessionResourceToReleaseListRelCmd *ngapType.PDUSessionResourceToReleaseListRelCmd) {
	handlePDUSessionResourceReleaseCommandMain(ran, ranUe, rANPagingPriority /* may be nil */, nASPDU /* may be nil */, pDUSessionResourceToReleaseListRelCmd)
}

func handlePDUSessionResourceReleaseCommandMain(ran *context.AmfRan, ranUe *context.RanUe, rANPagingPriority *ngapType.RANPagingPriority, nASPDU *ngapType.NASPDU, pDUSessionResourceToReleaseListRelCmd *ngapType.PDUSessionResourceToReleaseListRelCmd) {
	ran.Log.Error("Handle PDUSessionResourceReleaseCommand: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodePDUSessionResourceRelease
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPDUSessionResourceReleaseResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceReleasedListRelRes *ngapType.PDUSessionResourceReleasedListRelRes
	var userLocationInformation *ngapType.UserLocationInformation
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceReleaseResponse := successfulOutcome.Value.PDUSessionResourceReleaseResponse
	if pDUSessionResourceReleaseResponse == nil {
		ran.Log.Error("PDUSessionResourceReleaseResponse is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceReleaseResponse")

	for _, ie := range pDUSessionResourceReleaseResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceReleasedListRelRes: // mandatory, ignore
			if pDUSessionResourceReleasedListRelRes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceReleasedListRelRes")
				abort = true
				break
			}
			pDUSessionResourceReleasedListRelRes = ie.Value.PDUSessionResourceReleasedListRelRes
			ran.Log.Trace("Decode IE PDUSessionResourceReleasedListRelRes")
		case ngapType.ProtocolIEIDUserLocationInformation: // optional, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceRelease
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if pDUSessionResourceReleasedListRelRes == nil {
		ran.Log.Warn("Missing IE PDUSessionResourceReleasedListRelRes")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle PDUSessionResourceReleaseResponse: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle PDUSessionResourceReleaseResponse: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle PDUSessionResourceReleaseResponse (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handlePDUSessionResourceReleaseResponseMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceReleasedListRelRes *ngapType.PDUSessionResourceReleasedListRelRes,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handlePDUSessionResourceReleaseResponseMain(ran, ranUe /* may be nil */, pDUSessionResourceReleasedListRelRes /* may be nil */, userLocationInformation /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerPDUSessionResourceSetupRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rANPagingPriority *ngapType.RANPagingPriority
	var nASPDU *ngapType.NASPDU
	var pDUSessionResourceSetupListSUReq *ngapType.PDUSessionResourceSetupListSUReq
	var uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceSetupRequest := initiatingMessage.Value.PDUSessionResourceSetupRequest
	if pDUSessionResourceSetupRequest == nil {
		ran.Log.Error("PDUSessionResourceSetupRequest is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceSetupRequest")

	for _, ie := range pDUSessionResourceSetupRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANPagingPriority: // optional, ignore
			if rANPagingPriority != nil {
				ran.Log.Error("Duplicate IE RANPagingPriority")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANPagingPriority = ie.Value.RANPagingPriority
			ran.Log.Trace("Decode IE RANPagingPriority")
		case ngapType.ProtocolIEIDNASPDU: // optional, reject
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDPDUSessionResourceSetupListSUReq: // mandatory, reject
			if pDUSessionResourceSetupListSUReq != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSetupListSUReq")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceSetupListSUReq = ie.Value.PDUSessionResourceSetupListSUReq
			ran.Log.Trace("Decode IE PDUSessionResourceSetupListSUReq")
		case ngapType.ProtocolIEIDUEAggregateMaximumBitRate: // optional, ignore
			if uEAggregateMaximumBitRate != nil {
				ran.Log.Error("Duplicate IE UEAggregateMaximumBitRate")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEAggregateMaximumBitRate = ie.Value.UEAggregateMaximumBitRate
			ran.Log.Trace("Decode IE UEAggregateMaximumBitRate")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceSetupListSUReq == nil {
		ran.Log.Error("Missing IE PDUSessionResourceSetupListSUReq")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceSetupListSUReq, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceSetup
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if pDUSessionResourceSetupListSUReq == nil {
		ran.Log.Error("Missing IE PDUSessionResourceSetupListSUReq")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle PDUSessionResourceSetupRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle PDUSessionResourceSetupRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle PDUSessionResourceSetupRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handlePDUSessionResourceSetupRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rANPagingPriority *ngapType.RANPagingPriority,
	//	nASPDU *ngapType.NASPDU,
	//	pDUSessionResourceSetupListSUReq *ngapType.PDUSessionResourceSetupListSUReq,
	//	uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate) {
	handlePDUSessionResourceSetupRequestMain(ran, ranUe, rANPagingPriority /* may be nil */, nASPDU /* may be nil */, pDUSessionResourceSetupListSUReq, uEAggregateMaximumBitRate /* may be nil */)
}

func handlePDUSessionResourceSetupRequestMain(ran *context.AmfRan, ranUe *context.RanUe, rANPagingPriority *ngapType.RANPagingPriority, nASPDU *ngapType.NASPDU, pDUSessionResourceSetupListSUReq *ngapType.PDUSessionResourceSetupListSUReq, uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate) {
	ran.Log.Error("Handle PDUSessionResourceSetupRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodePDUSessionResourceSetup
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPDUSessionResourceSetupResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceSetupListSURes *ngapType.PDUSessionResourceSetupListSURes
	var pDUSessionResourceFailedToSetupListSURes *ngapType.PDUSessionResourceFailedToSetupListSURes
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pDUSessionResourceSetupResponse := successfulOutcome.Value.PDUSessionResourceSetupResponse
	if pDUSessionResourceSetupResponse == nil {
		ran.Log.Error("PDUSessionResourceSetupResponse is nil")
		return
	}

	ran.Log.Info("Handle PDUSessionResourceSetupResponse")

	for _, ie := range pDUSessionResourceSetupResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceSetupListSURes: // optional, ignore
			if pDUSessionResourceSetupListSURes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSetupListSURes")
				abort = true
				break
			}
			pDUSessionResourceSetupListSURes = ie.Value.PDUSessionResourceSetupListSURes
			ran.Log.Trace("Decode IE PDUSessionResourceSetupListSURes")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToSetupListSURes: // optional, ignore
			if pDUSessionResourceFailedToSetupListSURes != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToSetupListSURes")
				abort = true
				break
			}
			pDUSessionResourceFailedToSetupListSURes = ie.Value.PDUSessionResourceFailedToSetupListSURes
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToSetupListSURes")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePDUSessionResourceSetup
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle PDUSessionResourceSetupResponse: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle PDUSessionResourceSetupResponse: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle PDUSessionResourceSetupResponse (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handlePDUSessionResourceSetupResponseMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceSetupListSURes *ngapType.PDUSessionResourceSetupListSURes,
	//	pDUSessionResourceFailedToSetupListSURes *ngapType.PDUSessionResourceFailedToSetupListSURes,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handlePDUSessionResourceSetupResponseMain(ran, ranUe /* may be nil */, pDUSessionResourceSetupListSURes /* may be nil */, pDUSessionResourceFailedToSetupListSURes /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerPWSCancelRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var messageIdentifier *ngapType.MessageIdentifier
	var serialNumber *ngapType.SerialNumber
	var warningAreaList *ngapType.WarningAreaList
	var cancelAllWarningMessages *ngapType.CancelAllWarningMessages

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pWSCancelRequest := initiatingMessage.Value.PWSCancelRequest
	if pWSCancelRequest == nil {
		ran.Log.Error("PWSCancelRequest is nil")
		return
	}

	ran.Log.Info("Handle PWSCancelRequest")

	for _, ie := range pWSCancelRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDMessageIdentifier: // mandatory, reject
			if messageIdentifier != nil {
				ran.Log.Error("Duplicate IE MessageIdentifier")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			messageIdentifier = ie.Value.MessageIdentifier
			ran.Log.Trace("Decode IE MessageIdentifier")
		case ngapType.ProtocolIEIDSerialNumber: // mandatory, reject
			if serialNumber != nil {
				ran.Log.Error("Duplicate IE SerialNumber")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			serialNumber = ie.Value.SerialNumber
			ran.Log.Trace("Decode IE SerialNumber")
		case ngapType.ProtocolIEIDWarningAreaList: // optional, ignore
			if warningAreaList != nil {
				ran.Log.Error("Duplicate IE WarningAreaList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			warningAreaList = ie.Value.WarningAreaList
			ran.Log.Trace("Decode IE WarningAreaList")
		case ngapType.ProtocolIEIDCancelAllWarningMessages: // optional, reject
			if cancelAllWarningMessages != nil {
				ran.Log.Error("Duplicate IE CancelAllWarningMessages")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cancelAllWarningMessages = ie.Value.CancelAllWarningMessages
			ran.Log.Trace("Decode IE CancelAllWarningMessages")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if messageIdentifier == nil {
		ran.Log.Error("Missing IE MessageIdentifier")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDMessageIdentifier, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if serialNumber == nil {
		ran.Log.Error("Missing IE SerialNumber")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSerialNumber, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePWSCancel
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if messageIdentifier == nil {
		ran.Log.Error("Missing IE MessageIdentifier")
		return
	}
	if serialNumber == nil {
		ran.Log.Error("Missing IE SerialNumber")
		return
	}

	// func handlePWSCancelRequestMain(ran *context.AmfRan,
	//	messageIdentifier *ngapType.MessageIdentifier,
	//	serialNumber *ngapType.SerialNumber,
	//	warningAreaList *ngapType.WarningAreaList,
	//	cancelAllWarningMessages *ngapType.CancelAllWarningMessages) {
	handlePWSCancelRequestMain(ran, messageIdentifier, serialNumber, warningAreaList /* may be nil */, cancelAllWarningMessages /* may be nil */)
}

func handlePWSCancelRequestMain(ran *context.AmfRan, messageIdentifier *ngapType.MessageIdentifier, serialNumber *ngapType.SerialNumber, warningAreaList *ngapType.WarningAreaList, cancelAllWarningMessages *ngapType.CancelAllWarningMessages) {
	ran.Log.Error("Handle PWSCancelRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodePWSCancel
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPWSCancelResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var messageIdentifier *ngapType.MessageIdentifier
	var serialNumber *ngapType.SerialNumber
	var broadcastCancelledAreaList *ngapType.BroadcastCancelledAreaList
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pWSCancelResponse := successfulOutcome.Value.PWSCancelResponse
	if pWSCancelResponse == nil {
		ran.Log.Error("PWSCancelResponse is nil")
		return
	}

	ran.Log.Info("Handle PWSCancelResponse")

	for _, ie := range pWSCancelResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDMessageIdentifier: // mandatory, reject
			if messageIdentifier != nil {
				ran.Log.Error("Duplicate IE MessageIdentifier")
				abort = true
				break
			}
			messageIdentifier = ie.Value.MessageIdentifier
			ran.Log.Trace("Decode IE MessageIdentifier")
		case ngapType.ProtocolIEIDSerialNumber: // mandatory, reject
			if serialNumber != nil {
				ran.Log.Error("Duplicate IE SerialNumber")
				abort = true
				break
			}
			serialNumber = ie.Value.SerialNumber
			ran.Log.Trace("Decode IE SerialNumber")
		case ngapType.ProtocolIEIDBroadcastCancelledAreaList: // optional, ignore
			if broadcastCancelledAreaList != nil {
				ran.Log.Error("Duplicate IE BroadcastCancelledAreaList")
				abort = true
				break
			}
			broadcastCancelledAreaList = ie.Value.BroadcastCancelledAreaList
			ran.Log.Trace("Decode IE BroadcastCancelledAreaList")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePWSCancel
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if messageIdentifier == nil {
		ran.Log.Error("Missing IE MessageIdentifier")
		return
	}
	if serialNumber == nil {
		ran.Log.Error("Missing IE SerialNumber")
		return
	}

	// func handlePWSCancelResponseMain(ran *context.AmfRan,
	//	messageIdentifier *ngapType.MessageIdentifier,
	//	serialNumber *ngapType.SerialNumber,
	//	broadcastCancelledAreaList *ngapType.BroadcastCancelledAreaList,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handlePWSCancelResponseMain(ran, messageIdentifier, serialNumber, broadcastCancelledAreaList /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlePWSCancelResponseMain(ran *context.AmfRan, messageIdentifier *ngapType.MessageIdentifier, serialNumber *ngapType.SerialNumber, broadcastCancelledAreaList *ngapType.BroadcastCancelledAreaList, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle PWSCancelResponse: not implemented")
}

func handlerPWSFailureIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var pWSFailedCellIDList *ngapType.PWSFailedCellIDList
	var globalRANNodeID *ngapType.GlobalRANNodeID

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pWSFailureIndication := initiatingMessage.Value.PWSFailureIndication
	if pWSFailureIndication == nil {
		ran.Log.Error("PWSFailureIndication is nil")
		return
	}

	ran.Log.Info("Handle PWSFailureIndication")

	for _, ie := range pWSFailureIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDPWSFailedCellIDList: // mandatory, reject
			if pWSFailedCellIDList != nil {
				ran.Log.Error("Duplicate IE PWSFailedCellIDList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pWSFailedCellIDList = ie.Value.PWSFailedCellIDList
			ran.Log.Trace("Decode IE PWSFailedCellIDList")
		case ngapType.ProtocolIEIDGlobalRANNodeID: // mandatory, reject
			if globalRANNodeID != nil {
				ran.Log.Error("Duplicate IE GlobalRANNodeID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			globalRANNodeID = ie.Value.GlobalRANNodeID
			ran.Log.Trace("Decode IE GlobalRANNodeID")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if pWSFailedCellIDList == nil {
		ran.Log.Error("Missing IE PWSFailedCellIDList")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPWSFailedCellIDList, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if globalRANNodeID == nil {
		ran.Log.Error("Missing IE GlobalRANNodeID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDGlobalRANNodeID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePWSFailureIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if pWSFailedCellIDList == nil {
		ran.Log.Error("Missing IE PWSFailedCellIDList")
		return
	}
	if globalRANNodeID == nil {
		ran.Log.Error("Missing IE GlobalRANNodeID")
		return
	}

	// func handlePWSFailureIndicationMain(ran *context.AmfRan,
	//	pWSFailedCellIDList *ngapType.PWSFailedCellIDList,
	//	globalRANNodeID *ngapType.GlobalRANNodeID) {
	handlePWSFailureIndicationMain(ran, pWSFailedCellIDList, globalRANNodeID)
}

func handlePWSFailureIndicationMain(ran *context.AmfRan, pWSFailedCellIDList *ngapType.PWSFailedCellIDList, globalRANNodeID *ngapType.GlobalRANNodeID) {
	ran.Log.Error("Handle PWSFailureIndication: not implemented")
	procedureCode := ngapType.ProcedureCodePWSFailureIndication
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentUnspecified,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPWSRestartIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var cellIDListForRestart *ngapType.CellIDListForRestart
	var globalRANNodeID *ngapType.GlobalRANNodeID
	var tAIListForRestart *ngapType.TAIListForRestart
	var emergencyAreaIDListForRestart *ngapType.EmergencyAreaIDListForRestart

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pWSRestartIndication := initiatingMessage.Value.PWSRestartIndication
	if pWSRestartIndication == nil {
		ran.Log.Error("PWSRestartIndication is nil")
		return
	}

	ran.Log.Info("Handle PWSRestartIndication")

	for _, ie := range pWSRestartIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDCellIDListForRestart: // mandatory, reject
			if cellIDListForRestart != nil {
				ran.Log.Error("Duplicate IE CellIDListForRestart")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cellIDListForRestart = ie.Value.CellIDListForRestart
			ran.Log.Trace("Decode IE CellIDListForRestart")
		case ngapType.ProtocolIEIDGlobalRANNodeID: // mandatory, reject
			if globalRANNodeID != nil {
				ran.Log.Error("Duplicate IE GlobalRANNodeID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			globalRANNodeID = ie.Value.GlobalRANNodeID
			ran.Log.Trace("Decode IE GlobalRANNodeID")
		case ngapType.ProtocolIEIDTAIListForRestart: // mandatory, reject
			if tAIListForRestart != nil {
				ran.Log.Error("Duplicate IE TAIListForRestart")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			tAIListForRestart = ie.Value.TAIListForRestart
			ran.Log.Trace("Decode IE TAIListForRestart")
		case ngapType.ProtocolIEIDEmergencyAreaIDListForRestart: // optional, reject
			if emergencyAreaIDListForRestart != nil {
				ran.Log.Error("Duplicate IE EmergencyAreaIDListForRestart")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			emergencyAreaIDListForRestart = ie.Value.EmergencyAreaIDListForRestart
			ran.Log.Trace("Decode IE EmergencyAreaIDListForRestart")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if cellIDListForRestart == nil {
		ran.Log.Error("Missing IE CellIDListForRestart")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDCellIDListForRestart, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if globalRANNodeID == nil {
		ran.Log.Error("Missing IE GlobalRANNodeID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDGlobalRANNodeID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if tAIListForRestart == nil {
		ran.Log.Error("Missing IE TAIListForRestart")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDTAIListForRestart, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePWSRestartIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if cellIDListForRestart == nil {
		ran.Log.Error("Missing IE CellIDListForRestart")
		return
	}
	if globalRANNodeID == nil {
		ran.Log.Error("Missing IE GlobalRANNodeID")
		return
	}
	if tAIListForRestart == nil {
		ran.Log.Error("Missing IE TAIListForRestart")
		return
	}

	// func handlePWSRestartIndicationMain(ran *context.AmfRan,
	//	cellIDListForRestart *ngapType.CellIDListForRestart,
	//	globalRANNodeID *ngapType.GlobalRANNodeID,
	//	tAIListForRestart *ngapType.TAIListForRestart,
	//	emergencyAreaIDListForRestart *ngapType.EmergencyAreaIDListForRestart) {
	handlePWSRestartIndicationMain(ran, cellIDListForRestart, globalRANNodeID, tAIListForRestart, emergencyAreaIDListForRestart /* may be nil */)
}

func handlePWSRestartIndicationMain(ran *context.AmfRan, cellIDListForRestart *ngapType.CellIDListForRestart, globalRANNodeID *ngapType.GlobalRANNodeID, tAIListForRestart *ngapType.TAIListForRestart, emergencyAreaIDListForRestart *ngapType.EmergencyAreaIDListForRestart) {
	ran.Log.Error("Handle PWSRestartIndication: not implemented")
	procedureCode := ngapType.ProcedureCodePWSRestartIndication
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentUnspecified,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPaging(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var uEPagingIdentity *ngapType.UEPagingIdentity
	var pagingDRX *ngapType.PagingDRX
	var tAIListForPaging *ngapType.TAIListForPaging
	var pagingPriority *ngapType.PagingPriority
	var uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging
	var pagingOrigin *ngapType.PagingOrigin
	var assistanceDataForPaging *ngapType.AssistanceDataForPaging

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	paging := initiatingMessage.Value.Paging
	if paging == nil {
		ran.Log.Error("Paging is nil")
		return
	}

	ran.Log.Info("Handle Paging")

	for _, ie := range paging.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDUEPagingIdentity: // mandatory, ignore
			if uEPagingIdentity != nil {
				ran.Log.Error("Duplicate IE UEPagingIdentity")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEPagingIdentity = ie.Value.UEPagingIdentity
			ran.Log.Trace("Decode IE UEPagingIdentity")
		case ngapType.ProtocolIEIDPagingDRX: // optional, ignore
			if pagingDRX != nil {
				ran.Log.Error("Duplicate IE PagingDRX")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pagingDRX = ie.Value.PagingDRX
			ran.Log.Trace("Decode IE PagingDRX")
		case ngapType.ProtocolIEIDTAIListForPaging: // mandatory, ignore
			if tAIListForPaging != nil {
				ran.Log.Error("Duplicate IE TAIListForPaging")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			tAIListForPaging = ie.Value.TAIListForPaging
			ran.Log.Trace("Decode IE TAIListForPaging")
		case ngapType.ProtocolIEIDPagingPriority: // optional, ignore
			if pagingPriority != nil {
				ran.Log.Error("Duplicate IE PagingPriority")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pagingPriority = ie.Value.PagingPriority
			ran.Log.Trace("Decode IE PagingPriority")
		case ngapType.ProtocolIEIDUERadioCapabilityForPaging: // optional, ignore
			if uERadioCapabilityForPaging != nil {
				ran.Log.Error("Duplicate IE UERadioCapabilityForPaging")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERadioCapabilityForPaging = ie.Value.UERadioCapabilityForPaging
			ran.Log.Trace("Decode IE UERadioCapabilityForPaging")
		case ngapType.ProtocolIEIDPagingOrigin: // optional, ignore
			if pagingOrigin != nil {
				ran.Log.Error("Duplicate IE PagingOrigin")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pagingOrigin = ie.Value.PagingOrigin
			ran.Log.Trace("Decode IE PagingOrigin")
		case ngapType.ProtocolIEIDAssistanceDataForPaging: // optional, ignore
			if assistanceDataForPaging != nil {
				ran.Log.Error("Duplicate IE AssistanceDataForPaging")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			assistanceDataForPaging = ie.Value.AssistanceDataForPaging
			ran.Log.Trace("Decode IE AssistanceDataForPaging")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePaging
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if uEPagingIdentity == nil {
		ran.Log.Warn("Missing IE UEPagingIdentity")
	}
	if tAIListForPaging == nil {
		ran.Log.Warn("Missing IE TAIListForPaging")
	}

	// func handlePagingMain(ran *context.AmfRan,
	//	uEPagingIdentity *ngapType.UEPagingIdentity,
	//	pagingDRX *ngapType.PagingDRX,
	//	tAIListForPaging *ngapType.TAIListForPaging,
	//	pagingPriority *ngapType.PagingPriority,
	//	uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging,
	//	pagingOrigin *ngapType.PagingOrigin,
	//	assistanceDataForPaging *ngapType.AssistanceDataForPaging) {
	handlePagingMain(ran, uEPagingIdentity /* may be nil */, pagingDRX /* may be nil */, tAIListForPaging /* may be nil */, pagingPriority /* may be nil */, uERadioCapabilityForPaging /* may be nil */, pagingOrigin /* may be nil */, assistanceDataForPaging /* may be nil */)
}

func handlePagingMain(ran *context.AmfRan, uEPagingIdentity *ngapType.UEPagingIdentity, pagingDRX *ngapType.PagingDRX, tAIListForPaging *ngapType.TAIListForPaging, pagingPriority *ngapType.PagingPriority, uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging, pagingOrigin *ngapType.PagingOrigin, assistanceDataForPaging *ngapType.AssistanceDataForPaging) {
	ran.Log.Error("Handle Paging: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodePaging
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerPathSwitchRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var rANUENGAPID *ngapType.RANUENGAPID
	var sourceAMFUENGAPID *ngapType.AMFUENGAPID
	var userLocationInformation *ngapType.UserLocationInformation
	var uESecurityCapabilities *ngapType.UESecurityCapabilities
	var pDUSessionResourceToBeSwitchedDLList *ngapType.PDUSessionResourceToBeSwitchedDLList
	var pDUSessionResourceFailedToSetupListPSReq *ngapType.PDUSessionResourceFailedToSetupListPSReq

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pathSwitchRequest := initiatingMessage.Value.PathSwitchRequest
	if pathSwitchRequest == nil {
		ran.Log.Error("PathSwitchRequest is nil")
		return
	}

	ran.Log.Info("Handle PathSwitchRequest")

	for _, ie := range pathSwitchRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDSourceAMFUENGAPID: // mandatory, reject
			if sourceAMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			sourceAMFUENGAPID = ie.Value.SourceAMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUserLocationInformation: // mandatory, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDUESecurityCapabilities: // mandatory, ignore
			if uESecurityCapabilities != nil {
				ran.Log.Error("Duplicate IE UESecurityCapabilities")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uESecurityCapabilities = ie.Value.UESecurityCapabilities
			ran.Log.Trace("Decode IE UESecurityCapabilities")
		case ngapType.ProtocolIEIDPDUSessionResourceToBeSwitchedDLList: // mandatory, reject
			if pDUSessionResourceToBeSwitchedDLList != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceToBeSwitchedDLList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceToBeSwitchedDLList = ie.Value.PDUSessionResourceToBeSwitchedDLList
			ran.Log.Trace("Decode IE PDUSessionResourceToBeSwitchedDLList")
		case ngapType.ProtocolIEIDPDUSessionResourceFailedToSetupListPSReq: // optional, ignore
			if pDUSessionResourceFailedToSetupListPSReq != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceFailedToSetupListPSReq")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceFailedToSetupListPSReq = ie.Value.PDUSessionResourceFailedToSetupListPSReq
			ran.Log.Trace("Decode IE PDUSessionResourceFailedToSetupListPSReq")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if sourceAMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSourceAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if pDUSessionResourceToBeSwitchedDLList == nil {
		ran.Log.Error("Missing IE PDUSessionResourceToBeSwitchedDLList")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDPDUSessionResourceToBeSwitchedDLList, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePathSwitchRequest
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if sourceAMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if userLocationInformation == nil {
		ran.Log.Warn("Missing IE UserLocationInformation")
	}
	if uESecurityCapabilities == nil {
		ran.Log.Warn("Missing IE UESecurityCapabilities")
	}
	if pDUSessionResourceToBeSwitchedDLList == nil {
		ran.Log.Error("Missing IE PDUSessionResourceToBeSwitchedDLList")
		return
	}

	// func handlePathSwitchRequestMain(ran *context.AmfRan,
	//	rANUENGAPID *ngapType.RANUENGAPID,
	//	sourceAMFUENGAPID *ngapType.AMFUENGAPID,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	uESecurityCapabilities *ngapType.UESecurityCapabilities,
	//	pDUSessionResourceToBeSwitchedDLList *ngapType.PDUSessionResourceToBeSwitchedDLList,
	//	pDUSessionResourceFailedToSetupListPSReq *ngapType.PDUSessionResourceFailedToSetupListPSReq) {
	handlePathSwitchRequestMain(ran, rANUENGAPID, sourceAMFUENGAPID, userLocationInformation /* may be nil */, uESecurityCapabilities /* may be nil */, pDUSessionResourceToBeSwitchedDLList, pDUSessionResourceFailedToSetupListPSReq /* may be nil */)
}

func handlerPathSwitchRequestAcknowledge(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var uESecurityCapabilities *ngapType.UESecurityCapabilities
	var securityContext *ngapType.SecurityContext
	var newSecurityContextInd *ngapType.NewSecurityContextInd
	var pDUSessionResourceSwitchedList *ngapType.PDUSessionResourceSwitchedList
	var pDUSessionResourceReleasedListPSAck *ngapType.PDUSessionResourceReleasedListPSAck
	var allowedNSSAI *ngapType.AllowedNSSAI
	var coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation
	var rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics
	var redirectionVoiceFallback *ngapType.RedirectionVoiceFallback

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pathSwitchRequestAcknowledge := successfulOutcome.Value.PathSwitchRequestAcknowledge
	if pathSwitchRequestAcknowledge == nil {
		ran.Log.Error("PathSwitchRequestAcknowledge is nil")
		return
	}

	ran.Log.Info("Handle PathSwitchRequestAcknowledge")

	for _, ie := range pathSwitchRequestAcknowledge.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUESecurityCapabilities: // optional, reject
			if uESecurityCapabilities != nil {
				ran.Log.Error("Duplicate IE UESecurityCapabilities")
				abort = true
				break
			}
			uESecurityCapabilities = ie.Value.UESecurityCapabilities
			ran.Log.Trace("Decode IE UESecurityCapabilities")
		case ngapType.ProtocolIEIDSecurityContext: // mandatory, reject
			if securityContext != nil {
				ran.Log.Error("Duplicate IE SecurityContext")
				abort = true
				break
			}
			securityContext = ie.Value.SecurityContext
			ran.Log.Trace("Decode IE SecurityContext")
		case ngapType.ProtocolIEIDNewSecurityContextInd: // optional, reject
			if newSecurityContextInd != nil {
				ran.Log.Error("Duplicate IE NewSecurityContextInd")
				abort = true
				break
			}
			newSecurityContextInd = ie.Value.NewSecurityContextInd
			ran.Log.Trace("Decode IE NewSecurityContextInd")
		case ngapType.ProtocolIEIDPDUSessionResourceSwitchedList: // mandatory, ignore
			if pDUSessionResourceSwitchedList != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSwitchedList")
				abort = true
				break
			}
			pDUSessionResourceSwitchedList = ie.Value.PDUSessionResourceSwitchedList
			ran.Log.Trace("Decode IE PDUSessionResourceSwitchedList")
		case ngapType.ProtocolIEIDPDUSessionResourceReleasedListPSAck: // optional, ignore
			if pDUSessionResourceReleasedListPSAck != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceReleasedListPSAck")
				abort = true
				break
			}
			pDUSessionResourceReleasedListPSAck = ie.Value.PDUSessionResourceReleasedListPSAck
			ran.Log.Trace("Decode IE PDUSessionResourceReleasedListPSAck")
		case ngapType.ProtocolIEIDAllowedNSSAI: // mandatory, reject
			if allowedNSSAI != nil {
				ran.Log.Error("Duplicate IE AllowedNSSAI")
				abort = true
				break
			}
			allowedNSSAI = ie.Value.AllowedNSSAI
			ran.Log.Trace("Decode IE AllowedNSSAI")
		case ngapType.ProtocolIEIDCoreNetworkAssistanceInformation: // optional, ignore
			if coreNetworkAssistanceInformation != nil {
				ran.Log.Error("Duplicate IE CoreNetworkAssistanceInformationForInactive")
				abort = true
				break
			}
			coreNetworkAssistanceInformation = ie.Value.CoreNetworkAssistanceInformation
			ran.Log.Trace("Decode IE CoreNetworkAssistanceInformationForInactive")
		case ngapType.ProtocolIEIDRRCInactiveTransitionReportRequest: // optional, ignore
			if rRCInactiveTransitionReportRequest != nil {
				ran.Log.Error("Duplicate IE RRCInactiveTransitionReportRequest")
				abort = true
				break
			}
			rRCInactiveTransitionReportRequest = ie.Value.RRCInactiveTransitionReportRequest
			ran.Log.Trace("Decode IE RRCInactiveTransitionReportRequest")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		case ngapType.ProtocolIEIDRedirectionVoiceFallback: // optional, ignore
			if redirectionVoiceFallback != nil {
				ran.Log.Error("Duplicate IE RedirectionVoiceFallback")
				abort = true
				break
			}
			redirectionVoiceFallback = ie.Value.RedirectionVoiceFallback
			ran.Log.Trace("Decode IE RedirectionVoiceFallback")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePathSwitchRequest
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if securityContext == nil {
		ran.Log.Error("Missing IE SecurityContext")
		return
	}
	if pDUSessionResourceSwitchedList == nil {
		ran.Log.Warn("Missing IE PDUSessionResourceSwitchedList")
	}
	if allowedNSSAI == nil {
		ran.Log.Error("Missing IE AllowedNSSAI")
		return
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle PathSwitchRequestAcknowledge: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle PathSwitchRequestAcknowledge: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle PathSwitchRequestAcknowledge (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handlePathSwitchRequestAcknowledgeMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	uESecurityCapabilities *ngapType.UESecurityCapabilities,
	//	securityContext *ngapType.SecurityContext,
	//	newSecurityContextInd *ngapType.NewSecurityContextInd,
	//	pDUSessionResourceSwitchedList *ngapType.PDUSessionResourceSwitchedList,
	//	pDUSessionResourceReleasedListPSAck *ngapType.PDUSessionResourceReleasedListPSAck,
	//	allowedNSSAI *ngapType.AllowedNSSAI,
	//	coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation,
	//	rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics,
	//	redirectionVoiceFallback *ngapType.RedirectionVoiceFallback) {
	handlePathSwitchRequestAcknowledgeMain(ran, ranUe /* may be nil */, uESecurityCapabilities /* may be nil */, securityContext, newSecurityContextInd /* may be nil */, pDUSessionResourceSwitchedList /* may be nil */, pDUSessionResourceReleasedListPSAck /* may be nil */, allowedNSSAI, coreNetworkAssistanceInformation /* may be nil */, rRCInactiveTransitionReportRequest /* may be nil */, criticalityDiagnostics /* may be nil */, redirectionVoiceFallback /* may be nil */)
}

func handlePathSwitchRequestAcknowledgeMain(ran *context.AmfRan, ranUe *context.RanUe, uESecurityCapabilities *ngapType.UESecurityCapabilities, securityContext *ngapType.SecurityContext, newSecurityContextInd *ngapType.NewSecurityContextInd, pDUSessionResourceSwitchedList *ngapType.PDUSessionResourceSwitchedList, pDUSessionResourceReleasedListPSAck *ngapType.PDUSessionResourceReleasedListPSAck, allowedNSSAI *ngapType.AllowedNSSAI, coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation, rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest, criticalityDiagnostics *ngapType.CriticalityDiagnostics, redirectionVoiceFallback *ngapType.RedirectionVoiceFallback) {
	ran.Log.Error("Handle PathSwitchRequestAcknowledge: AMF to RAN message")
}

func handlerPathSwitchRequestFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceReleasedListPSFail *ngapType.PDUSessionResourceReleasedListPSFail
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	pathSwitchRequestFailure := unsuccessfulOutcome.Value.PathSwitchRequestFailure
	if pathSwitchRequestFailure == nil {
		ran.Log.Error("PathSwitchRequestFailure is nil")
		return
	}

	ran.Log.Info("Handle PathSwitchRequestFailure")

	for _, ie := range pathSwitchRequestFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceReleasedListPSFail: // mandatory, ignore
			if pDUSessionResourceReleasedListPSFail != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceReleasedListPSFail")
				abort = true
				break
			}
			pDUSessionResourceReleasedListPSFail = ie.Value.PDUSessionResourceReleasedListPSFail
			ran.Log.Trace("Decode IE PDUSessionResourceReleasedListPSFail")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodePathSwitchRequest
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if pDUSessionResourceReleasedListPSFail == nil {
		ran.Log.Warn("Missing IE PDUSessionResourceReleasedListPSFail")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle PathSwitchRequestFailure: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle PathSwitchRequestFailure: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle PathSwitchRequestFailure (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handlePathSwitchRequestFailureMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceReleasedListPSFail *ngapType.PDUSessionResourceReleasedListPSFail,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handlePathSwitchRequestFailureMain(ran, ranUe /* may be nil */, pDUSessionResourceReleasedListPSFail /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlePathSwitchRequestFailureMain(ran *context.AmfRan, ranUe *context.RanUe, pDUSessionResourceReleasedListPSFail *ngapType.PDUSessionResourceReleasedListPSFail, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle PathSwitchRequestFailure: AMF to RAN message")
}

func handlerRANConfigurationUpdate(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var rANNodeName *ngapType.RANNodeName
	var supportedTAList *ngapType.SupportedTAList
	var defaultPagingDRX *ngapType.PagingDRX
	var globalRANNodeID *ngapType.GlobalRANNodeID

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	rANConfigurationUpdate := initiatingMessage.Value.RANConfigurationUpdate
	if rANConfigurationUpdate == nil {
		ran.Log.Error("RANConfigurationUpdate is nil")
		return
	}

	ran.Log.Info("Handle RANConfigurationUpdate")

	for _, ie := range rANConfigurationUpdate.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDRANNodeName: // optional, ignore
			if rANNodeName != nil {
				ran.Log.Error("Duplicate IE RANNodeName")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANNodeName = ie.Value.RANNodeName
			ran.Log.Trace("Decode IE RANNodeName")
		case ngapType.ProtocolIEIDSupportedTAList: // optional, reject
			if supportedTAList != nil {
				ran.Log.Error("Duplicate IE SupportedTAList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			supportedTAList = ie.Value.SupportedTAList
			ran.Log.Trace("Decode IE SupportedTAList")
		case ngapType.ProtocolIEIDDefaultPagingDRX: // optional, ignore
			if defaultPagingDRX != nil {
				ran.Log.Error("Duplicate IE PagingDRX")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			defaultPagingDRX = ie.Value.DefaultPagingDRX
			ran.Log.Trace("Decode IE PagingDRX")
		case ngapType.ProtocolIEIDGlobalRANNodeID: // optional, ignore
			if globalRANNodeID != nil {
				ran.Log.Error("Duplicate IE GlobalRANNodeID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			globalRANNodeID = ie.Value.GlobalRANNodeID
			ran.Log.Trace("Decode IE GlobalRANNodeID")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeRANConfigurationUpdate
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		if syntaxCause == nil {
			syntaxCause = &ngapType.Cause{
				Present: ngapType.CausePresentProtocol,
				Protocol: &ngapType.CauseProtocol{
					Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
				},
			}
		}
		rawSendRANConfigurationUpdateFailure(ran, *syntaxCause, nil, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if rANNodeName != nil {
		ran.Log.Warn("IE RANNodeName is not implemented")
	}
	if defaultPagingDRX != nil {
		ran.Log.Warn("IE PagingDRX is not implemented")
	}
	if globalRANNodeID != nil {
		ran.Log.Warn("IE GlobalRANNodeID is not implemented")
	}

	// func handleRANConfigurationUpdateMain(ran *context.AmfRan,
	//	supportedTAList *ngapType.SupportedTAList) {
	handleRANConfigurationUpdateMain(ran, supportedTAList /* may be nil */)
}

func handlerRANConfigurationUpdateAcknowledge(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	rANConfigurationUpdateAcknowledge := successfulOutcome.Value.RANConfigurationUpdateAcknowledge
	if rANConfigurationUpdateAcknowledge == nil {
		ran.Log.Error("RANConfigurationUpdateAcknowledge is nil")
		return
	}

	ran.Log.Info("Handle RANConfigurationUpdateAcknowledge")

	for _, ie := range rANConfigurationUpdateAcknowledge.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeRANConfigurationUpdate
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	// func handleRANConfigurationUpdateAcknowledgeMain(ran *context.AmfRan,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleRANConfigurationUpdateAcknowledgeMain(ran, criticalityDiagnostics /* may be nil */)
}

func handleRANConfigurationUpdateAcknowledgeMain(ran *context.AmfRan, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle RANConfigurationUpdateAcknowledge: AMF to RAN message")
}

func handlerRANConfigurationUpdateFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var cause *ngapType.Cause
	var timeToWait *ngapType.TimeToWait
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	rANConfigurationUpdateFailure := unsuccessfulOutcome.Value.RANConfigurationUpdateFailure
	if rANConfigurationUpdateFailure == nil {
		ran.Log.Error("RANConfigurationUpdateFailure is nil")
		return
	}

	ran.Log.Info("Handle RANConfigurationUpdateFailure")

	for _, ie := range rANConfigurationUpdateFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDTimeToWait: // optional, ignore
			if timeToWait != nil {
				ran.Log.Error("Duplicate IE TimeToWait")
				abort = true
				break
			}
			timeToWait = ie.Value.TimeToWait
			ran.Log.Trace("Decode IE TimeToWait")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeRANConfigurationUpdate
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// func handleRANConfigurationUpdateFailureMain(ran *context.AmfRan,
	//	cause *ngapType.Cause,
	//	timeToWait *ngapType.TimeToWait,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleRANConfigurationUpdateFailureMain(ran, cause /* may be nil */, timeToWait /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handleRANConfigurationUpdateFailureMain(ran *context.AmfRan, cause *ngapType.Cause, timeToWait *ngapType.TimeToWait, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle RANConfigurationUpdateFailure: AMF to RAN message")
}

func handlerRRCInactiveTransitionReport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rRCState *ngapType.RRCState
	var userLocationInformation *ngapType.UserLocationInformation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	rRCInactiveTransitionReport := initiatingMessage.Value.RRCInactiveTransitionReport
	if rRCInactiveTransitionReport == nil {
		ran.Log.Error("RRCInactiveTransitionReport is nil")
		return
	}

	ran.Log.Info("Handle RRCInactiveTransitionReport")

	for _, ie := range rRCInactiveTransitionReport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRRCState: // mandatory, ignore
			if rRCState != nil {
				ran.Log.Error("Duplicate IE RRCState")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rRCState = ie.Value.RRCState
			ran.Log.Trace("Decode IE RRCState")
		case ngapType.ProtocolIEIDUserLocationInformation: // mandatory, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeRRCInactiveTransitionReport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if rRCState == nil {
		ran.Log.Warn("Missing IE RRCState")
	}
	if userLocationInformation == nil {
		ran.Log.Warn("Missing IE UserLocationInformation")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle RRCInactiveTransitionReport: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle RRCInactiveTransitionReport: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle RRCInactiveTransitionReport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleRRCInactiveTransitionReportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rRCState *ngapType.RRCState,
	//	userLocationInformation *ngapType.UserLocationInformation) {
	handleRRCInactiveTransitionReportMain(ran, ranUe, rRCState /* may be nil */, userLocationInformation /* may be nil */)
}

func handlerRerouteNASRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var rANUENGAPID *ngapType.RANUENGAPID
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var aMFSetID *ngapType.AMFSetID
	var allowedNSSAI *ngapType.AllowedNSSAI

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	rerouteNASRequest := initiatingMessage.Value.RerouteNASRequest
	if rerouteNASRequest == nil {
		ran.Log.Error("RerouteNASRequest is nil")
		return
	}

	ran.Log.Info("Handle RerouteNASRequest")

	for _, ie := range rerouteNASRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDAMFUENGAPID: // optional, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDAMFSetID: // mandatory, reject
			if aMFSetID != nil {
				ran.Log.Error("Duplicate IE AMFSetID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFSetID = ie.Value.AMFSetID
			ran.Log.Trace("Decode IE AMFSetID")
		case ngapType.ProtocolIEIDAllowedNSSAI: // optional, reject
			if allowedNSSAI != nil {
				ran.Log.Error("Duplicate IE AllowedNSSAI")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			allowedNSSAI = ie.Value.AllowedNSSAI
			ran.Log.Trace("Decode IE AllowedNSSAI")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if aMFSetID == nil {
		ran.Log.Error("Missing IE AMFSetID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFSetID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeRerouteNASRequest
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if aMFSetID == nil {
		ran.Log.Error("Missing IE AMFSetID")
		return
	}

	// AMF: optional, ignore
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle RerouteNASRequest: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle RerouteNASRequest: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle RerouteNASRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleRerouteNASRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	aMFSetID *ngapType.AMFSetID,
	//	allowedNSSAI *ngapType.AllowedNSSAI) {
	handleRerouteNASRequestMain(ran, ranUe /* may be nil */, aMFSetID, allowedNSSAI /* may be nil */)
}

func handleRerouteNASRequestMain(ran *context.AmfRan, ranUe *context.RanUe, aMFSetID *ngapType.AMFSetID, allowedNSSAI *ngapType.AllowedNSSAI) {
	ran.Log.Error("Handle RerouteNASRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeRerouteNASRequest
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerSecondaryRATDataUsageReport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceSecondaryRATUsageList *ngapType.PDUSessionResourceSecondaryRATUsageList
	var handoverFlag *ngapType.HandoverFlag

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	secondaryRATDataUsageReport := initiatingMessage.Value.SecondaryRATDataUsageReport
	if secondaryRATDataUsageReport == nil {
		ran.Log.Error("SecondaryRATDataUsageReport is nil")
		return
	}

	ran.Log.Info("Handle SecondaryRATDataUsageReport")

	for _, ie := range secondaryRATDataUsageReport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceSecondaryRATUsageList: // mandatory, ignore
			if pDUSessionResourceSecondaryRATUsageList != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceSecondaryRATUsageList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceSecondaryRATUsageList = ie.Value.PDUSessionResourceSecondaryRATUsageList
			ran.Log.Trace("Decode IE PDUSessionResourceSecondaryRATUsageList")
		case ngapType.ProtocolIEIDHandoverFlag: // optional, ignore
			if handoverFlag != nil {
				ran.Log.Error("Duplicate IE HandoverFlag")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			handoverFlag = ie.Value.HandoverFlag
			ran.Log.Trace("Decode IE HandoverFlag")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeSecondaryRATDataUsageReport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if pDUSessionResourceSecondaryRATUsageList == nil {
		ran.Log.Warn("Missing IE PDUSessionResourceSecondaryRATUsageList")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle SecondaryRATDataUsageReport: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle SecondaryRATDataUsageReport: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle SecondaryRATDataUsageReport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleSecondaryRATDataUsageReportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceSecondaryRATUsageList *ngapType.PDUSessionResourceSecondaryRATUsageList,
	//	handoverFlag *ngapType.HandoverFlag) {
	handleSecondaryRATDataUsageReportMain(ran, ranUe /* may be nil */, pDUSessionResourceSecondaryRATUsageList /* may be nil */, handoverFlag /* may be nil */)
}

func handleSecondaryRATDataUsageReportMain(ran *context.AmfRan, ranUe *context.RanUe, pDUSessionResourceSecondaryRATUsageList *ngapType.PDUSessionResourceSecondaryRATUsageList, handoverFlag *ngapType.HandoverFlag) {
	ran.Log.Error("Handle SecondaryRATDataUsageReport: not implemented")
	procedureCode := ngapType.ProcedureCodeSecondaryRATDataUsageReport
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentUnspecified,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerTraceFailureIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var nGRANTraceID *ngapType.NGRANTraceID
	var cause *ngapType.Cause

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	traceFailureIndication := initiatingMessage.Value.TraceFailureIndication
	if traceFailureIndication == nil {
		ran.Log.Error("TraceFailureIndication is nil")
		return
	}

	ran.Log.Info("Handle TraceFailureIndication")

	for _, ie := range traceFailureIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDNGRANTraceID: // mandatory, ignore
			if nGRANTraceID != nil {
				ran.Log.Error("Duplicate IE NGRANTraceID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nGRANTraceID = ie.Value.NGRANTraceID
			ran.Log.Trace("Decode IE NGRANTraceID")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeTraceFailureIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nGRANTraceID == nil {
		ran.Log.Warn("Missing IE NGRANTraceID")
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle TraceFailureIndication: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle TraceFailureIndication: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle TraceFailureIndication (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleTraceFailureIndicationMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	nGRANTraceID *ngapType.NGRANTraceID,
	//	cause *ngapType.Cause) {
	handleTraceFailureIndicationMain(ran, ranUe, nGRANTraceID /* may be nil */, cause /* may be nil */)
}

func handleTraceFailureIndicationMain(ran *context.AmfRan, ranUe *context.RanUe, nGRANTraceID *ngapType.NGRANTraceID, cause *ngapType.Cause) {
	ran.Log.Error("Handle TraceFailureIndication: not implemented")
	procedureCode := ngapType.ProcedureCodeTraceFailureIndication
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentUnspecified,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerTraceStart(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var traceActivation *ngapType.TraceActivation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	traceStart := initiatingMessage.Value.TraceStart
	if traceStart == nil {
		ran.Log.Error("TraceStart is nil")
		return
	}

	ran.Log.Info("Handle TraceStart")

	for _, ie := range traceStart.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDTraceActivation: // mandatory, ignore
			if traceActivation != nil {
				ran.Log.Error("Duplicate IE TraceActivation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			traceActivation = ie.Value.TraceActivation
			ran.Log.Trace("Decode IE TraceActivation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeTraceStart
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if traceActivation == nil {
		ran.Log.Warn("Missing IE TraceActivation")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle TraceStart: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle TraceStart: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle TraceStart (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleTraceStartMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	traceActivation *ngapType.TraceActivation) {
	handleTraceStartMain(ran, ranUe, traceActivation /* may be nil */)
}

func handleTraceStartMain(ran *context.AmfRan, ranUe *context.RanUe, traceActivation *ngapType.TraceActivation) {
	ran.Log.Error("Handle TraceStart: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeTraceStart
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerUEContextModificationFailure(ran *context.AmfRan, unsuccessfulOutcome *ngapType.UnsuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var cause *ngapType.Cause
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uEContextModificationFailure := unsuccessfulOutcome.Value.UEContextModificationFailure
	if uEContextModificationFailure == nil {
		ran.Log.Error("UEContextModificationFailure is nil")
		return
	}

	ran.Log.Info("Handle UEContextModificationFailure")

	for _, ie := range uEContextModificationFailure.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUEContextModification
		triggeringMessage := ngapType.TriggeringMessagePresentUnsuccessfullOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle UEContextModificationFailure: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle UEContextModificationFailure: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle UEContextModificationFailure (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleUEContextModificationFailureMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	cause *ngapType.Cause,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleUEContextModificationFailureMain(ran, ranUe /* may be nil */, cause /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerUEContextModificationRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rANPagingPriority *ngapType.RANPagingPriority
	var securityKey *ngapType.SecurityKey
	var indexToRFSP *ngapType.IndexToRFSP
	var uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate
	var uESecurityCapabilities *ngapType.UESecurityCapabilities
	var coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation
	var emergencyFallbackIndicator *ngapType.EmergencyFallbackIndicator
	var newAMFUENGAPID *ngapType.AMFUENGAPID
	var rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uEContextModificationRequest := initiatingMessage.Value.UEContextModificationRequest
	if uEContextModificationRequest == nil {
		ran.Log.Error("UEContextModificationRequest is nil")
		return
	}

	ran.Log.Info("Handle UEContextModificationRequest")

	for _, ie := range uEContextModificationRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANPagingPriority: // optional, ignore
			if rANPagingPriority != nil {
				ran.Log.Error("Duplicate IE RANPagingPriority")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANPagingPriority = ie.Value.RANPagingPriority
			ran.Log.Trace("Decode IE RANPagingPriority")
		case ngapType.ProtocolIEIDSecurityKey: // optional, reject
			if securityKey != nil {
				ran.Log.Error("Duplicate IE SecurityKey")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			securityKey = ie.Value.SecurityKey
			ran.Log.Trace("Decode IE SecurityKey")
		case ngapType.ProtocolIEIDIndexToRFSP: // optional, ignore
			if indexToRFSP != nil {
				ran.Log.Error("Duplicate IE IndexToRFSP")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			indexToRFSP = ie.Value.IndexToRFSP
			ran.Log.Trace("Decode IE IndexToRFSP")
		case ngapType.ProtocolIEIDUEAggregateMaximumBitRate: // optional, ignore
			if uEAggregateMaximumBitRate != nil {
				ran.Log.Error("Duplicate IE UEAggregateMaximumBitRate")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uEAggregateMaximumBitRate = ie.Value.UEAggregateMaximumBitRate
			ran.Log.Trace("Decode IE UEAggregateMaximumBitRate")
		case ngapType.ProtocolIEIDUESecurityCapabilities: // optional, reject
			if uESecurityCapabilities != nil {
				ran.Log.Error("Duplicate IE UESecurityCapabilities")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uESecurityCapabilities = ie.Value.UESecurityCapabilities
			ran.Log.Trace("Decode IE UESecurityCapabilities")
		case ngapType.ProtocolIEIDCoreNetworkAssistanceInformation: // optional, ignore
			if coreNetworkAssistanceInformation != nil {
				ran.Log.Error("Duplicate IE CoreNetworkAssistanceInformationForInactive")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			coreNetworkAssistanceInformation = ie.Value.CoreNetworkAssistanceInformation
			ran.Log.Trace("Decode IE CoreNetworkAssistanceInformationForInactive")
		case ngapType.ProtocolIEIDEmergencyFallbackIndicator: // optional, reject
			if emergencyFallbackIndicator != nil {
				ran.Log.Error("Duplicate IE EmergencyFallbackIndicator")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			emergencyFallbackIndicator = ie.Value.EmergencyFallbackIndicator
			ran.Log.Trace("Decode IE EmergencyFallbackIndicator")
		case ngapType.ProtocolIEIDNewAMFUENGAPID: // optional, reject
			if newAMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			newAMFUENGAPID = ie.Value.NewAMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRRCInactiveTransitionReportRequest: // optional, ignore
			if rRCInactiveTransitionReportRequest != nil {
				ran.Log.Error("Duplicate IE RRCInactiveTransitionReportRequest")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rRCInactiveTransitionReportRequest = ie.Value.RRCInactiveTransitionReportRequest
			ran.Log.Trace("Decode IE RRCInactiveTransitionReportRequest")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUEContextModification
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UEContextModificationRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UEContextModificationRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UEContextModificationRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUEContextModificationRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rANPagingPriority *ngapType.RANPagingPriority,
	//	securityKey *ngapType.SecurityKey,
	//	indexToRFSP *ngapType.IndexToRFSP,
	//	uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate,
	//	uESecurityCapabilities *ngapType.UESecurityCapabilities,
	//	coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation,
	//	emergencyFallbackIndicator *ngapType.EmergencyFallbackIndicator,
	//	newAMFUENGAPID *ngapType.AMFUENGAPID,
	//	rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest) {
	handleUEContextModificationRequestMain(ran, ranUe, rANPagingPriority /* may be nil */, securityKey /* may be nil */, indexToRFSP /* may be nil */, uEAggregateMaximumBitRate /* may be nil */, uESecurityCapabilities /* may be nil */, coreNetworkAssistanceInformation /* may be nil */, emergencyFallbackIndicator /* may be nil */, newAMFUENGAPID /* may be nil */, rRCInactiveTransitionReportRequest /* may be nil */)
}

func handleUEContextModificationRequestMain(ran *context.AmfRan, ranUe *context.RanUe, rANPagingPriority *ngapType.RANPagingPriority, securityKey *ngapType.SecurityKey, indexToRFSP *ngapType.IndexToRFSP, uEAggregateMaximumBitRate *ngapType.UEAggregateMaximumBitRate, uESecurityCapabilities *ngapType.UESecurityCapabilities, coreNetworkAssistanceInformation *ngapType.CoreNetworkAssistanceInformation, emergencyFallbackIndicator *ngapType.EmergencyFallbackIndicator, newAMFUENGAPID *ngapType.AMFUENGAPID, rRCInactiveTransitionReportRequest *ngapType.RRCInactiveTransitionReportRequest) {
	ran.Log.Error("Handle UEContextModificationRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeUEContextModification
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerUEContextModificationResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rRCState *ngapType.RRCState
	var userLocationInformation *ngapType.UserLocationInformation
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uEContextModificationResponse := successfulOutcome.Value.UEContextModificationResponse
	if uEContextModificationResponse == nil {
		ran.Log.Error("UEContextModificationResponse is nil")
		return
	}

	ran.Log.Info("Handle UEContextModificationResponse")

	for _, ie := range uEContextModificationResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRRCState: // optional, ignore
			if rRCState != nil {
				ran.Log.Error("Duplicate IE RRCState")
				abort = true
				break
			}
			rRCState = ie.Value.RRCState
			ran.Log.Trace("Decode IE RRCState")
		case ngapType.ProtocolIEIDUserLocationInformation: // optional, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUEContextModification
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle UEContextModificationResponse: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle UEContextModificationResponse: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle UEContextModificationResponse (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleUEContextModificationResponseMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	rRCState *ngapType.RRCState,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleUEContextModificationResponseMain(ran, ranUe /* may be nil */, rRCState /* may be nil */, userLocationInformation /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerUEContextReleaseCommand(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var uENGAPIDs *ngapType.UENGAPIDs
	var cause *ngapType.Cause

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uEContextReleaseCommand := initiatingMessage.Value.UEContextReleaseCommand
	if uEContextReleaseCommand == nil {
		ran.Log.Error("UEContextReleaseCommand is nil")
		return
	}

	ran.Log.Info("Handle UEContextReleaseCommand")

	for _, ie := range uEContextReleaseCommand.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDUENGAPIDs: // mandatory, reject
			if uENGAPIDs != nil {
				ran.Log.Error("Duplicate IE UE-NGAP-IDs")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uENGAPIDs = ie.Value.UENGAPIDs
			ran.Log.Trace("Decode IE UE-NGAP-IDs")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if uENGAPIDs == nil {
		ran.Log.Error("Missing IE UE-NGAP-IDs")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDUENGAPIDs, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUEContextRelease
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if uENGAPIDs == nil {
		ran.Log.Error("Missing IE UE-NGAP-IDs")
		return
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// func handleUEContextReleaseCommandMain(ran *context.AmfRan,
	//	uENGAPIDs *ngapType.UENGAPIDs,
	//	cause *ngapType.Cause) {
	handleUEContextReleaseCommandMain(ran, uENGAPIDs, cause /* may be nil */)
}

func handleUEContextReleaseCommandMain(ran *context.AmfRan, uENGAPIDs *ngapType.UENGAPIDs, cause *ngapType.Cause) {
	ran.Log.Error("Handle UEContextReleaseCommand: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeUEContextRelease
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerUEContextReleaseComplete(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var userLocationInformation *ngapType.UserLocationInformation
	var infoOnRecommendedCellsAndRANNodesForPaging *ngapType.InfoOnRecommendedCellsAndRANNodesForPaging
	var pDUSessionResourceListCxtRelCpl *ngapType.PDUSessionResourceListCxtRelCpl
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uEContextReleaseComplete := successfulOutcome.Value.UEContextReleaseComplete
	if uEContextReleaseComplete == nil {
		ran.Log.Error("UEContextReleaseComplete is nil")
		return
	}

	ran.Log.Info("Handle UEContextReleaseComplete")

	for _, ie := range uEContextReleaseComplete.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUserLocationInformation: // optional, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		case ngapType.ProtocolIEIDInfoOnRecommendedCellsAndRANNodesForPaging: // optional, ignore
			if infoOnRecommendedCellsAndRANNodesForPaging != nil {
				ran.Log.Error("Duplicate IE InfoOnRecommendedCellsAndRANNodesForPaging")
				abort = true
				break
			}
			infoOnRecommendedCellsAndRANNodesForPaging = ie.Value.InfoOnRecommendedCellsAndRANNodesForPaging
			ran.Log.Trace("Decode IE InfoOnRecommendedCellsAndRANNodesForPaging")
		case ngapType.ProtocolIEIDPDUSessionResourceListCxtRelCpl: // optional, reject
			if pDUSessionResourceListCxtRelCpl != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceListCxtRelCpl")
				abort = true
				break
			}
			pDUSessionResourceListCxtRelCpl = ie.Value.PDUSessionResourceListCxtRelCpl
			ran.Log.Trace("Decode IE PDUSessionResourceListCxtRelCpl")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUEContextRelease
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, false)
		if err != nil {
			ran.Log.Errorf("Handle UEContextReleaseComplete: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle UEContextReleaseComplete: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle UEContextReleaseComplete (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleUEContextReleaseCompleteMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	userLocationInformation *ngapType.UserLocationInformation,
	//	infoOnRecommendedCellsAndRANNodesForPaging *ngapType.InfoOnRecommendedCellsAndRANNodesForPaging,
	//	pDUSessionResourceListCxtRelCpl *ngapType.PDUSessionResourceListCxtRelCpl,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleUEContextReleaseCompleteMain(ran, ranUe /* may be nil */, userLocationInformation /* may be nil */, infoOnRecommendedCellsAndRANNodesForPaging /* may be nil */, pDUSessionResourceListCxtRelCpl /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerUEContextReleaseRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var pDUSessionResourceListCxtRelReq *ngapType.PDUSessionResourceListCxtRelReq
	var cause *ngapType.Cause

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uEContextReleaseRequest := initiatingMessage.Value.UEContextReleaseRequest
	if uEContextReleaseRequest == nil {
		ran.Log.Error("UEContextReleaseRequest is nil")
		return
	}

	ran.Log.Info("Handle UEContextReleaseRequest")

	for _, ie := range uEContextReleaseRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDPDUSessionResourceListCxtRelReq: // optional, reject
			if pDUSessionResourceListCxtRelReq != nil {
				ran.Log.Error("Duplicate IE PDUSessionResourceListCxtRelReq")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			pDUSessionResourceListCxtRelReq = ie.Value.PDUSessionResourceListCxtRelReq
			ran.Log.Trace("Decode IE PDUSessionResourceListCxtRelReq")
		case ngapType.ProtocolIEIDCause: // mandatory, ignore
			if cause != nil {
				ran.Log.Error("Duplicate IE Cause")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			cause = ie.Value.Cause
			ran.Log.Trace("Decode IE Cause")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUEContextReleaseRequest
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if cause == nil {
		ran.Log.Warn("Missing IE Cause")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UEContextReleaseRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UEContextReleaseRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UEContextReleaseRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUEContextReleaseRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	pDUSessionResourceListCxtRelReq *ngapType.PDUSessionResourceListCxtRelReq,
	//	cause *ngapType.Cause) {
	handleUEContextReleaseRequestMain(ran, ranUe, pDUSessionResourceListCxtRelReq /* may be nil */, cause /* may be nil */)
}

func handlerUERadioCapabilityCheckRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var uERadioCapability *ngapType.UERadioCapability

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uERadioCapabilityCheckRequest := initiatingMessage.Value.UERadioCapabilityCheckRequest
	if uERadioCapabilityCheckRequest == nil {
		ran.Log.Error("UERadioCapabilityCheckRequest is nil")
		return
	}

	ran.Log.Info("Handle UERadioCapabilityCheckRequest")

	for _, ie := range uERadioCapabilityCheckRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUERadioCapability: // optional, ignore
			if uERadioCapability != nil {
				ran.Log.Error("Duplicate IE UERadioCapability")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERadioCapability = ie.Value.UERadioCapability
			ran.Log.Trace("Decode IE UERadioCapability")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUERadioCapabilityCheck
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UERadioCapabilityCheckRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UERadioCapabilityCheckRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UERadioCapabilityCheckRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUERadioCapabilityCheckRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	uERadioCapability *ngapType.UERadioCapability) {
	handleUERadioCapabilityCheckRequestMain(ran, ranUe, uERadioCapability /* may be nil */)
}

func handleUERadioCapabilityCheckRequestMain(ran *context.AmfRan, ranUe *context.RanUe, uERadioCapability *ngapType.UERadioCapability) {
	ran.Log.Error("Handle UERadioCapabilityCheckRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeUERadioCapabilityCheck
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerUERadioCapabilityCheckResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var iMSVoiceSupportIndicator *ngapType.IMSVoiceSupportIndicator
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uERadioCapabilityCheckResponse := successfulOutcome.Value.UERadioCapabilityCheckResponse
	if uERadioCapabilityCheckResponse == nil {
		ran.Log.Error("UERadioCapabilityCheckResponse is nil")
		return
	}

	ran.Log.Info("Handle UERadioCapabilityCheckResponse")

	for _, ie := range uERadioCapabilityCheckResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, ignore
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, ignore
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDIMSVoiceSupportIndicator: // mandatory, reject
			if iMSVoiceSupportIndicator != nil {
				ran.Log.Error("Duplicate IE IMSVoiceSupportIndicator")
				abort = true
				break
			}
			iMSVoiceSupportIndicator = ie.Value.IMSVoiceSupportIndicator
			ran.Log.Trace("Decode IE IMSVoiceSupportIndicator")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUERadioCapabilityCheck
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Warn("Missing IE AMF-UE-NGAP-ID")
	}
	if rANUENGAPID == nil {
		ran.Log.Warn("Missing IE RAN-UE-NGAP-ID")
	}
	if iMSVoiceSupportIndicator == nil {
		ran.Log.Error("Missing IE IMSVoiceSupportIndicator")
		return
	}
	if iMSVoiceSupportIndicator != nil {
		ran.Log.Warn("IE IMSVoiceSupportIndicator is not implemented")
	}

	// AMF: mandatory, ignore
	// RAN: mandatory, ignore
	var ranUe *context.RanUe
	if aMFUENGAPID != nil {
		var err error
		ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
		if err != nil {
			ran.Log.Errorf("Handle UERadioCapabilityCheckResponse: %s", err)
			return
		}
		if ranUe == nil {
			ran.Log.Error("Handle UERadioCapabilityCheckResponse: No UE Context")
			return
		}
		ranUe.Log.Infof("Handle UERadioCapabilityCheckResponse (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)
	}

	// func handleUERadioCapabilityCheckResponseMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleUERadioCapabilityCheckResponseMain(ran, ranUe /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handlerUERadioCapabilityInfoIndication(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var uERadioCapability *ngapType.UERadioCapability
	var uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uERadioCapabilityInfoIndication := initiatingMessage.Value.UERadioCapabilityInfoIndication
	if uERadioCapabilityInfoIndication == nil {
		ran.Log.Error("UERadioCapabilityInfoIndication is nil")
		return
	}

	ran.Log.Info("Handle UERadioCapabilityInfoIndication")

	for _, ie := range uERadioCapabilityInfoIndication.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDUERadioCapability: // mandatory, ignore
			if uERadioCapability != nil {
				ran.Log.Error("Duplicate IE UERadioCapability")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERadioCapability = ie.Value.UERadioCapability
			ran.Log.Trace("Decode IE UERadioCapability")
		case ngapType.ProtocolIEIDUERadioCapabilityForPaging: // optional, ignore
			if uERadioCapabilityForPaging != nil {
				ran.Log.Error("Duplicate IE UERadioCapabilityForPaging")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			uERadioCapabilityForPaging = ie.Value.UERadioCapabilityForPaging
			ran.Log.Trace("Decode IE UERadioCapabilityForPaging")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUERadioCapabilityInfoIndication
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if uERadioCapability == nil {
		ran.Log.Warn("Missing IE UERadioCapability")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UERadioCapabilityInfoIndication: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UERadioCapabilityInfoIndication: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UERadioCapabilityInfoIndication (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUERadioCapabilityInfoIndicationMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	uERadioCapability *ngapType.UERadioCapability,
	//	uERadioCapabilityForPaging *ngapType.UERadioCapabilityForPaging) {
	handleUERadioCapabilityInfoIndicationMain(ran, ranUe, uERadioCapability /* may be nil */, uERadioCapabilityForPaging /* may be nil */)
}

func handlerUETNLABindingReleaseRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uETNLABindingReleaseRequest := initiatingMessage.Value.UETNLABindingReleaseRequest
	if uETNLABindingReleaseRequest == nil {
		ran.Log.Error("UETNLABindingReleaseRequest is nil")
		return
	}

	ran.Log.Info("Handle UETNLABindingReleaseRequest")

	for _, ie := range uETNLABindingReleaseRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUETNLABindingRelease
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UETNLABindingReleaseRequest: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UETNLABindingReleaseRequest: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UETNLABindingReleaseRequest (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUETNLABindingReleaseRequestMain(ran *context.AmfRan,
	//	ranUe *context.RanUe) {
	handleUETNLABindingReleaseRequestMain(ran, ranUe)
}

func handleUETNLABindingReleaseRequestMain(ran *context.AmfRan, ranUe *context.RanUe) {
	ran.Log.Error("Handle UETNLABindingReleaseRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeUETNLABindingRelease
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentIgnore
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerUplinkNASTransport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var nASPDU *ngapType.NASPDU
	var userLocationInformation *ngapType.UserLocationInformation

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uplinkNASTransport := initiatingMessage.Value.UplinkNASTransport
	if uplinkNASTransport == nil {
		ran.Log.Error("UplinkNASTransport is nil")
		return
	}

	ran.Log.Info("Handle UplinkNASTransport")

	for _, ie := range uplinkNASTransport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDNASPDU: // mandatory, reject
			if nASPDU != nil {
				ran.Log.Error("Duplicate IE NAS-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nASPDU = ie.Value.NASPDU
			ran.Log.Trace("Decode IE NAS-PDU")
		case ngapType.ProtocolIEIDUserLocationInformation: // mandatory, ignore
			if userLocationInformation != nil {
				ran.Log.Error("Duplicate IE UserLocationInformation")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			userLocationInformation = ie.Value.UserLocationInformation
			ran.Log.Trace("Decode IE UserLocationInformation")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nASPDU == nil {
		ran.Log.Error("Missing IE NAS-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNASPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUplinkNASTransport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if nASPDU == nil {
		ran.Log.Error("Missing IE NAS-PDU")
		return
	}
	if userLocationInformation == nil {
		ran.Log.Warn("Missing IE UserLocationInformation")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UplinkNASTransport: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UplinkNASTransport: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UplinkNASTransport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUplinkNASTransportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	nASPDU *ngapType.NASPDU,
	//	userLocationInformation *ngapType.UserLocationInformation) {
	handleUplinkNASTransportMain(ran, ranUe, nASPDU, userLocationInformation /* may be nil */)
}

func handlerUplinkNonUEAssociatedNRPPaTransport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var routingID *ngapType.RoutingID
	var nRPPaPDU *ngapType.NRPPaPDU

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uplinkNonUEAssociatedNRPPaTransport := initiatingMessage.Value.UplinkNonUEAssociatedNRPPaTransport
	if uplinkNonUEAssociatedNRPPaTransport == nil {
		ran.Log.Error("UplinkNonUEAssociatedNRPPaTransport is nil")
		return
	}

	ran.Log.Info("Handle UplinkNonUEAssociatedNRPPaTransport")

	for _, ie := range uplinkNonUEAssociatedNRPPaTransport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDRoutingID: // mandatory, reject
			if routingID != nil {
				ran.Log.Error("Duplicate IE RoutingID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			routingID = ie.Value.RoutingID
			ran.Log.Trace("Decode IE RoutingID")
		case ngapType.ProtocolIEIDNRPPaPDU: // mandatory, reject
			if nRPPaPDU != nil {
				ran.Log.Error("Duplicate IE NRPPa-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nRPPaPDU = ie.Value.NRPPaPDU
			ran.Log.Trace("Decode IE NRPPa-PDU")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRoutingID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNRPPaPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUplinkNonUEAssociatedNRPPaTransport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		return
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		return
	}

	// func handleUplinkNonUEAssociatedNRPPaTransportMain(ran *context.AmfRan,
	//	routingID *ngapType.RoutingID,
	//	nRPPaPDU *ngapType.NRPPaPDU) {
	handleUplinkNonUEAssociatedNRPPaTransportMain(ran, routingID, nRPPaPDU)
}

func handlerUplinkRANConfigurationTransfer(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var sONConfigurationTransferUL *ngapType.SONConfigurationTransfer
	var eNDCSONConfigurationTransferUL *ngapType.ENDCSONConfigurationTransfer

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uplinkRANConfigurationTransfer := initiatingMessage.Value.UplinkRANConfigurationTransfer
	if uplinkRANConfigurationTransfer == nil {
		ran.Log.Error("UplinkRANConfigurationTransfer is nil")
		return
	}

	ran.Log.Info("Handle UplinkRANConfigurationTransfer")

	for _, ie := range uplinkRANConfigurationTransfer.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDSONConfigurationTransferUL: // optional, ignore
			if sONConfigurationTransferUL != nil {
				ran.Log.Error("Duplicate IE SONConfigurationTransfer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			sONConfigurationTransferUL = ie.Value.SONConfigurationTransferUL
			ran.Log.Trace("Decode IE SONConfigurationTransfer")
		case ngapType.ProtocolIEIDENDCSONConfigurationTransferUL: // optional, ignore
			if eNDCSONConfigurationTransferUL != nil {
				ran.Log.Error("Duplicate IE EN-DCSONConfigurationTransfer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			eNDCSONConfigurationTransferUL = ie.Value.ENDCSONConfigurationTransferUL
			ran.Log.Trace("Decode IE EN-DCSONConfigurationTransfer")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUplinkRANConfigurationTransfer
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if eNDCSONConfigurationTransferUL != nil {
		ran.Log.Warn("IE EN-DCSONConfigurationTransfer is not implemented")
	}

	// func handleUplinkRANConfigurationTransferMain(ran *context.AmfRan,
	//	sONConfigurationTransferUL *ngapType.SONConfigurationTransfer) {
	handleUplinkRANConfigurationTransferMain(ran, sONConfigurationTransferUL /* may be nil */)
}

func handlerUplinkRANStatusTransfer(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var rANStatusTransferTransparentContainer *ngapType.RANStatusTransferTransparentContainer

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uplinkRANStatusTransfer := initiatingMessage.Value.UplinkRANStatusTransfer
	if uplinkRANStatusTransfer == nil {
		ran.Log.Error("UplinkRANStatusTransfer is nil")
		return
	}

	ran.Log.Info("Handle UplinkRANStatusTransfer")

	for _, ie := range uplinkRANStatusTransfer.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANStatusTransferTransparentContainer: // mandatory, reject
			if rANStatusTransferTransparentContainer != nil {
				ran.Log.Error("Duplicate IE RANStatusTransfer-TransparentContainer")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANStatusTransferTransparentContainer = ie.Value.RANStatusTransferTransparentContainer
			ran.Log.Trace("Decode IE RANStatusTransfer-TransparentContainer")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANStatusTransferTransparentContainer == nil {
		ran.Log.Error("Missing IE RANStatusTransfer-TransparentContainer")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANStatusTransferTransparentContainer, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUplinkRANStatusTransfer
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if rANStatusTransferTransparentContainer == nil {
		ran.Log.Error("Missing IE RANStatusTransfer-TransparentContainer")
		return
	}
	if rANStatusTransferTransparentContainer != nil {
		ran.Log.Warn("IE RANStatusTransfer-TransparentContainer is not implemented")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UplinkRANStatusTransfer: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UplinkRANStatusTransfer: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UplinkRANStatusTransfer (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUplinkRANStatusTransferMain(ran *context.AmfRan,
	//	ranUe *context.RanUe) {
	handleUplinkRANStatusTransferMain(ran, ranUe)
}

func handlerUplinkUEAssociatedNRPPaTransport(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var aMFUENGAPID *ngapType.AMFUENGAPID
	var rANUENGAPID *ngapType.RANUENGAPID
	var routingID *ngapType.RoutingID
	var nRPPaPDU *ngapType.NRPPaPDU

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	uplinkUEAssociatedNRPPaTransport := initiatingMessage.Value.UplinkUEAssociatedNRPPaTransport
	if uplinkUEAssociatedNRPPaTransport == nil {
		ran.Log.Error("UplinkUEAssociatedNRPPaTransport is nil")
		return
	}

	ran.Log.Info("Handle UplinkUEAssociatedNRPPaTransport")

	for _, ie := range uplinkUEAssociatedNRPPaTransport.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDAMFUENGAPID: // mandatory, reject
			if aMFUENGAPID != nil {
				ran.Log.Error("Duplicate IE AMF-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			aMFUENGAPID = ie.Value.AMFUENGAPID
			ran.Log.Trace("Decode IE AMF-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRANUENGAPID: // mandatory, reject
			if rANUENGAPID != nil {
				ran.Log.Error("Duplicate IE RAN-UE-NGAP-ID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			rANUENGAPID = ie.Value.RANUENGAPID
			ran.Log.Trace("Decode IE RAN-UE-NGAP-ID")
		case ngapType.ProtocolIEIDRoutingID: // mandatory, reject
			if routingID != nil {
				ran.Log.Error("Duplicate IE RoutingID")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			routingID = ie.Value.RoutingID
			ran.Log.Trace("Decode IE RoutingID")
		case ngapType.ProtocolIEIDNRPPaPDU: // mandatory, reject
			if nRPPaPDU != nil {
				ran.Log.Error("Duplicate IE NRPPa-PDU")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			nRPPaPDU = ie.Value.NRPPaPDU
			ran.Log.Trace("Decode IE NRPPa-PDU")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDAMFUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRANUENGAPID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRoutingID, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNRPPaPDU, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeUplinkUEAssociatedNRPPaTransport
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentIgnore
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, aMFUENGAPID, rANUENGAPID, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if aMFUENGAPID == nil {
		ran.Log.Error("Missing IE AMF-UE-NGAP-ID")
		return
	}
	if rANUENGAPID == nil {
		ran.Log.Error("Missing IE RAN-UE-NGAP-ID")
		return
	}
	if routingID == nil {
		ran.Log.Error("Missing IE RoutingID")
		return
	}
	if nRPPaPDU == nil {
		ran.Log.Error("Missing IE NRPPa-PDU")
		return
	}
	if nRPPaPDU != nil {
		ran.Log.Warn("IE NRPPa-PDU is not implemented")
	}

	// AMF: mandatory, reject
	// RAN: mandatory, reject
	var ranUe *context.RanUe
	var err error
	ranUe, err = ranUeFind(ran, aMFUENGAPID, rANUENGAPID, false, true)
	if err != nil {
		ran.Log.Errorf("Handle UplinkUEAssociatedNRPPaTransport: %s", err)
		return
	}
	if ranUe == nil {
		ran.Log.Error("Handle UplinkUEAssociatedNRPPaTransport: No UE Context")
		return
	}
	ranUe.Log.Infof("Handle UplinkUEAssociatedNRPPaTransport (RAN UE NGAP ID: %d)", ranUe.RanUeNgapId)

	// func handleUplinkUEAssociatedNRPPaTransportMain(ran *context.AmfRan,
	//	ranUe *context.RanUe,
	//	routingID *ngapType.RoutingID) {
	handleUplinkUEAssociatedNRPPaTransportMain(ran, ranUe, routingID)
}

func handlerWriteReplaceWarningRequest(ran *context.AmfRan, initiatingMessage *ngapType.InitiatingMessage) {
	var messageIdentifier *ngapType.MessageIdentifier
	var serialNumber *ngapType.SerialNumber
	var warningAreaList *ngapType.WarningAreaList
	var repetitionPeriod *ngapType.RepetitionPeriod
	var numberOfBroadcastsRequested *ngapType.NumberOfBroadcastsRequested
	var warningType *ngapType.WarningType
	var warningSecurityInfo *ngapType.WarningSecurityInfo
	var dataCodingScheme *ngapType.DataCodingScheme
	var warningMessageContents *ngapType.WarningMessageContents
	var concurrentWarningMessageInd *ngapType.ConcurrentWarningMessageInd
	var warningAreaCoordinates *ngapType.WarningAreaCoordinates

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	writeReplaceWarningRequest := initiatingMessage.Value.WriteReplaceWarningRequest
	if writeReplaceWarningRequest == nil {
		ran.Log.Error("WriteReplaceWarningRequest is nil")
		return
	}

	ran.Log.Info("Handle WriteReplaceWarningRequest")

	for _, ie := range writeReplaceWarningRequest.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDMessageIdentifier: // mandatory, reject
			if messageIdentifier != nil {
				ran.Log.Error("Duplicate IE MessageIdentifier")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			messageIdentifier = ie.Value.MessageIdentifier
			ran.Log.Trace("Decode IE MessageIdentifier")
		case ngapType.ProtocolIEIDSerialNumber: // mandatory, reject
			if serialNumber != nil {
				ran.Log.Error("Duplicate IE SerialNumber")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			serialNumber = ie.Value.SerialNumber
			ran.Log.Trace("Decode IE SerialNumber")
		case ngapType.ProtocolIEIDWarningAreaList: // optional, ignore
			if warningAreaList != nil {
				ran.Log.Error("Duplicate IE WarningAreaList")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			warningAreaList = ie.Value.WarningAreaList
			ran.Log.Trace("Decode IE WarningAreaList")
		case ngapType.ProtocolIEIDRepetitionPeriod: // mandatory, reject
			if repetitionPeriod != nil {
				ran.Log.Error("Duplicate IE RepetitionPeriod")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			repetitionPeriod = ie.Value.RepetitionPeriod
			ran.Log.Trace("Decode IE RepetitionPeriod")
		case ngapType.ProtocolIEIDNumberOfBroadcastsRequested: // mandatory, reject
			if numberOfBroadcastsRequested != nil {
				ran.Log.Error("Duplicate IE NumberOfBroadcastsRequested")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			numberOfBroadcastsRequested = ie.Value.NumberOfBroadcastsRequested
			ran.Log.Trace("Decode IE NumberOfBroadcastsRequested")
		case ngapType.ProtocolIEIDWarningType: // optional, ignore
			if warningType != nil {
				ran.Log.Error("Duplicate IE WarningType")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			warningType = ie.Value.WarningType
			ran.Log.Trace("Decode IE WarningType")
		case ngapType.ProtocolIEIDWarningSecurityInfo: // optional, ignore
			if warningSecurityInfo != nil {
				ran.Log.Error("Duplicate IE WarningSecurityInfo")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			warningSecurityInfo = ie.Value.WarningSecurityInfo
			ran.Log.Trace("Decode IE WarningSecurityInfo")
		case ngapType.ProtocolIEIDDataCodingScheme: // optional, ignore
			if dataCodingScheme != nil {
				ran.Log.Error("Duplicate IE DataCodingScheme")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			dataCodingScheme = ie.Value.DataCodingScheme
			ran.Log.Trace("Decode IE DataCodingScheme")
		case ngapType.ProtocolIEIDWarningMessageContents: // optional, ignore
			if warningMessageContents != nil {
				ran.Log.Error("Duplicate IE WarningMessageContents")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			warningMessageContents = ie.Value.WarningMessageContents
			ran.Log.Trace("Decode IE WarningMessageContents")
		case ngapType.ProtocolIEIDConcurrentWarningMessageInd: // optional, reject
			if concurrentWarningMessageInd != nil {
				ran.Log.Error("Duplicate IE ConcurrentWarningMessageInd")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			concurrentWarningMessageInd = ie.Value.ConcurrentWarningMessageInd
			ran.Log.Trace("Decode IE ConcurrentWarningMessageInd")
		case ngapType.ProtocolIEIDWarningAreaCoordinates: // optional, ignore
			if warningAreaCoordinates != nil {
				ran.Log.Error("Duplicate IE WarningAreaCoordinates")
				syntaxCause = &ngapType.Cause{
					Present: ngapType.CausePresentProtocol,
					Protocol: &ngapType.CauseProtocol{
						Value: ngapType.CauseProtocolPresentAbstractSyntaxErrorFalselyConstructedMessage,
					},
				}
				abort = true
				break
			}
			warningAreaCoordinates = ie.Value.WarningAreaCoordinates
			ran.Log.Trace("Decode IE WarningAreaCoordinates")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
			}
			if ie.Criticality.Value != ngapType.CriticalityPresentIgnore {
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
				if ie.Criticality.Value == ngapType.CriticalityPresentReject {
					abort = true
				}
			}
		}
	}

	if messageIdentifier == nil {
		ran.Log.Error("Missing IE MessageIdentifier")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDMessageIdentifier, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if serialNumber == nil {
		ran.Log.Error("Missing IE SerialNumber")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDSerialNumber, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if repetitionPeriod == nil {
		ran.Log.Error("Missing IE RepetitionPeriod")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDRepetitionPeriod, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}
	if numberOfBroadcastsRequested == nil {
		ran.Log.Error("Missing IE NumberOfBroadcastsRequested")
		item := buildCriticalityDiagnosticsIEItem(ngapType.CriticalityPresentReject, ngapType.ProtocolIEIDNumberOfBroadcastsRequested, ngapType.TypeOfErrorPresentMissing)
		iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
		abort = true
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeWriteReplaceWarning
		triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if messageIdentifier == nil {
		ran.Log.Error("Missing IE MessageIdentifier")
		return
	}
	if serialNumber == nil {
		ran.Log.Error("Missing IE SerialNumber")
		return
	}
	if repetitionPeriod == nil {
		ran.Log.Error("Missing IE RepetitionPeriod")
		return
	}
	if numberOfBroadcastsRequested == nil {
		ran.Log.Error("Missing IE NumberOfBroadcastsRequested")
		return
	}

	// func handleWriteReplaceWarningRequestMain(ran *context.AmfRan,
	//	messageIdentifier *ngapType.MessageIdentifier,
	//	serialNumber *ngapType.SerialNumber,
	//	warningAreaList *ngapType.WarningAreaList,
	//	repetitionPeriod *ngapType.RepetitionPeriod,
	//	numberOfBroadcastsRequested *ngapType.NumberOfBroadcastsRequested,
	//	warningType *ngapType.WarningType,
	//	warningSecurityInfo *ngapType.WarningSecurityInfo,
	//	dataCodingScheme *ngapType.DataCodingScheme,
	//	warningMessageContents *ngapType.WarningMessageContents,
	//	concurrentWarningMessageInd *ngapType.ConcurrentWarningMessageInd,
	//	warningAreaCoordinates *ngapType.WarningAreaCoordinates) {
	handleWriteReplaceWarningRequestMain(ran, messageIdentifier, serialNumber, warningAreaList /* may be nil */, repetitionPeriod, numberOfBroadcastsRequested, warningType /* may be nil */, warningSecurityInfo /* may be nil */, dataCodingScheme /* may be nil */, warningMessageContents /* may be nil */, concurrentWarningMessageInd /* may be nil */, warningAreaCoordinates /* may be nil */)
}

func handleWriteReplaceWarningRequestMain(ran *context.AmfRan, messageIdentifier *ngapType.MessageIdentifier, serialNumber *ngapType.SerialNumber, warningAreaList *ngapType.WarningAreaList, repetitionPeriod *ngapType.RepetitionPeriod, numberOfBroadcastsRequested *ngapType.NumberOfBroadcastsRequested, warningType *ngapType.WarningType, warningSecurityInfo *ngapType.WarningSecurityInfo, dataCodingScheme *ngapType.DataCodingScheme, warningMessageContents *ngapType.WarningMessageContents, concurrentWarningMessageInd *ngapType.ConcurrentWarningMessageInd, warningAreaCoordinates *ngapType.WarningAreaCoordinates) {
	ran.Log.Error("Handle WriteReplaceWarningRequest: AMF to RAN message")
	procedureCode := ngapType.ProcedureCodeWriteReplaceWarning
	triggeringMessage := ngapType.TriggeringMessagePresentInitiatingMessage
	procedureCriticality := ngapType.CriticalityPresentReject
	notImplementedCriticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, nil)
	notImplementedCause := &ngapType.Cause{
		Present: ngapType.CausePresentProtocol,
		Protocol: &ngapType.CauseProtocol{
			Value: ngapType.CauseProtocolPresentMessageNotCompatibleWithReceiverState,
		},
	}
	ngap_message.SendErrorIndication(ran, nil, nil, notImplementedCause, &notImplementedCriticalityDiagnostics)
}

func handlerWriteReplaceWarningResponse(ran *context.AmfRan, successfulOutcome *ngapType.SuccessfulOutcome) {
	var messageIdentifier *ngapType.MessageIdentifier
	var serialNumber *ngapType.SerialNumber
	var broadcastCompletedAreaList *ngapType.BroadcastCompletedAreaList
	var criticalityDiagnostics *ngapType.CriticalityDiagnostics

	var syntaxCause *ngapType.Cause
	var iesCriticalityDiagnostics ngapType.CriticalityDiagnosticsIEList
	abort := false

	writeReplaceWarningResponse := successfulOutcome.Value.WriteReplaceWarningResponse
	if writeReplaceWarningResponse == nil {
		ran.Log.Error("WriteReplaceWarningResponse is nil")
		return
	}

	ran.Log.Info("Handle WriteReplaceWarningResponse")

	for _, ie := range writeReplaceWarningResponse.ProtocolIEs.List {
		switch ie.Id.Value {
		case ngapType.ProtocolIEIDMessageIdentifier: // mandatory, reject
			if messageIdentifier != nil {
				ran.Log.Error("Duplicate IE MessageIdentifier")
				abort = true
				break
			}
			messageIdentifier = ie.Value.MessageIdentifier
			ran.Log.Trace("Decode IE MessageIdentifier")
		case ngapType.ProtocolIEIDSerialNumber: // mandatory, reject
			if serialNumber != nil {
				ran.Log.Error("Duplicate IE SerialNumber")
				abort = true
				break
			}
			serialNumber = ie.Value.SerialNumber
			ran.Log.Trace("Decode IE SerialNumber")
		case ngapType.ProtocolIEIDBroadcastCompletedAreaList: // optional, ignore
			if broadcastCompletedAreaList != nil {
				ran.Log.Error("Duplicate IE BroadcastCompletedAreaList")
				abort = true
				break
			}
			broadcastCompletedAreaList = ie.Value.BroadcastCompletedAreaList
			ran.Log.Trace("Decode IE BroadcastCompletedAreaList")
		case ngapType.ProtocolIEIDCriticalityDiagnostics: // optional, ignore
			if criticalityDiagnostics != nil {
				ran.Log.Error("Duplicate IE CriticalityDiagnostics")
				abort = true
				break
			}
			criticalityDiagnostics = ie.Value.CriticalityDiagnostics
			ran.Log.Trace("Decode IE CriticalityDiagnostics")
		default:
			switch ie.Criticality.Value {
			case ngapType.CriticalityPresentReject:
				ran.Log.Errorf("Not comprehended IE ID 0x%04x (criticality: reject)", ie.Id.Value)
			case ngapType.CriticalityPresentIgnore:
				ran.Log.Infof("Not comprehended IE ID 0x%04x (criticality: ignore)", ie.Id.Value)
			case ngapType.CriticalityPresentNotify:
				ran.Log.Warnf("Not comprehended IE ID 0x%04x (criticality: notify)", ie.Id.Value)
				item := buildCriticalityDiagnosticsIEItem(ie.Criticality.Value, ie.Id.Value, ngapType.TypeOfErrorPresentNotUnderstood)
				iesCriticalityDiagnostics.List = append(iesCriticalityDiagnostics.List, item)
			}
		}
	}

	if syntaxCause != nil || len(iesCriticalityDiagnostics.List) > 0 {
		ran.Log.Trace("Has IE error")
		procedureCode := ngapType.ProcedureCodeWriteReplaceWarning
		triggeringMessage := ngapType.TriggeringMessagePresentSuccessfulOutcome
		procedureCriticality := ngapType.CriticalityPresentReject
		var pIesCriticalityDiagnostics *ngapType.CriticalityDiagnosticsIEList
		if len(iesCriticalityDiagnostics.List) > 0 {
			pIesCriticalityDiagnostics = &iesCriticalityDiagnostics
		}
		criticalityDiagnostics := buildCriticalityDiagnostics(&procedureCode, &triggeringMessage, &procedureCriticality, pIesCriticalityDiagnostics)
		ngap_message.SendErrorIndication(ran, nil, nil, syntaxCause, &criticalityDiagnostics)
	}

	if abort {
		return
	}

	if messageIdentifier == nil {
		ran.Log.Error("Missing IE MessageIdentifier")
		return
	}
	if serialNumber == nil {
		ran.Log.Error("Missing IE SerialNumber")
		return
	}

	// func handleWriteReplaceWarningResponseMain(ran *context.AmfRan,
	//	messageIdentifier *ngapType.MessageIdentifier,
	//	serialNumber *ngapType.SerialNumber,
	//	broadcastCompletedAreaList *ngapType.BroadcastCompletedAreaList,
	//	criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	handleWriteReplaceWarningResponseMain(ran, messageIdentifier, serialNumber, broadcastCompletedAreaList /* may be nil */, criticalityDiagnostics /* may be nil */)
}

func handleWriteReplaceWarningResponseMain(ran *context.AmfRan, messageIdentifier *ngapType.MessageIdentifier, serialNumber *ngapType.SerialNumber, broadcastCompletedAreaList *ngapType.BroadcastCompletedAreaList, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	ran.Log.Error("Handle WriteReplaceWarningResponse: not implemented")
}

func rawBuildHandoverPreparationFailure(aMFUENGAPID *ngapType.AMFUENGAPID, rANUENGAPID *ngapType.RANUENGAPID, cause *ngapType.Cause, criticalityDiagnostics *ngapType.CriticalityDiagnostics) ([]byte, error) {
	var pdu ngapType.NGAPPDU

	pdu.Present = ngapType.NGAPPDUPresentUnsuccessfulOutcome
	pdu.UnsuccessfulOutcome = new(ngapType.UnsuccessfulOutcome)

	unsuccessfulOutcome := pdu.UnsuccessfulOutcome
	unsuccessfulOutcome.ProcedureCode.Value = ngapType.ProcedureCodeHandoverPreparation
	unsuccessfulOutcome.Criticality.Value = ngapType.CriticalityPresentReject

	unsuccessfulOutcome.Value.Present = ngapType.UnsuccessfulOutcomePresentHandoverPreparationFailure
	unsuccessfulOutcome.Value.HandoverPreparationFailure = new(ngapType.HandoverPreparationFailure)

	handoverPreparationFailure := unsuccessfulOutcome.Value.HandoverPreparationFailure
	handoverPreparationFailureIEs := &handoverPreparationFailure.ProtocolIEs
	handoverPreparationFailureIEs.List = make([]ngapType.HandoverPreparationFailureIEs, 0, 4)

	{
		ie := ngapType.HandoverPreparationFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDAMFUENGAPID
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.HandoverPreparationFailureIEsPresentAMFUENGAPID
		ie.Value.AMFUENGAPID = aMFUENGAPID
		handoverPreparationFailureIEs.List = append(handoverPreparationFailureIEs.List, ie)
	}

	{
		ie := ngapType.HandoverPreparationFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDRANUENGAPID
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.HandoverPreparationFailureIEsPresentRANUENGAPID
		ie.Value.RANUENGAPID = rANUENGAPID
		handoverPreparationFailureIEs.List = append(handoverPreparationFailureIEs.List, ie)
	}

	{
		ie := ngapType.HandoverPreparationFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCause
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.HandoverPreparationFailureIEsPresentCause
		ie.Value.Cause = cause
		handoverPreparationFailureIEs.List = append(handoverPreparationFailureIEs.List, ie)
	}

	if criticalityDiagnostics != nil {
		ie := ngapType.HandoverPreparationFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCriticalityDiagnostics
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.HandoverPreparationFailureIEsPresentCriticalityDiagnostics
		ie.Value.CriticalityDiagnostics = criticalityDiagnostics
		handoverPreparationFailureIEs.List = append(handoverPreparationFailureIEs.List, ie)
	}

	return ngap.Encoder(pdu)
}

func rawBuildNGSetupFailure(cause *ngapType.Cause, timeToWait *ngapType.TimeToWait, criticalityDiagnostics *ngapType.CriticalityDiagnostics) ([]byte, error) {
	var pdu ngapType.NGAPPDU

	pdu.Present = ngapType.NGAPPDUPresentUnsuccessfulOutcome
	pdu.UnsuccessfulOutcome = new(ngapType.UnsuccessfulOutcome)

	unsuccessfulOutcome := pdu.UnsuccessfulOutcome
	unsuccessfulOutcome.ProcedureCode.Value = ngapType.ProcedureCodeNGSetup
	unsuccessfulOutcome.Criticality.Value = ngapType.CriticalityPresentReject

	unsuccessfulOutcome.Value.Present = ngapType.UnsuccessfulOutcomePresentNGSetupFailure
	unsuccessfulOutcome.Value.NGSetupFailure = new(ngapType.NGSetupFailure)

	nGSetupFailure := unsuccessfulOutcome.Value.NGSetupFailure
	nGSetupFailureIEs := &nGSetupFailure.ProtocolIEs
	nGSetupFailureIEs.List = make([]ngapType.NGSetupFailureIEs, 0, 3)

	{
		ie := ngapType.NGSetupFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCause
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.NGSetupFailureIEsPresentCause
		ie.Value.Cause = cause
		nGSetupFailureIEs.List = append(nGSetupFailureIEs.List, ie)
	}

	if timeToWait != nil {
		ie := ngapType.NGSetupFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDTimeToWait
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.NGSetupFailureIEsPresentTimeToWait
		ie.Value.TimeToWait = timeToWait
		nGSetupFailureIEs.List = append(nGSetupFailureIEs.List, ie)
	}

	if criticalityDiagnostics != nil {
		ie := ngapType.NGSetupFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCriticalityDiagnostics
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.NGSetupFailureIEsPresentCriticalityDiagnostics
		ie.Value.CriticalityDiagnostics = criticalityDiagnostics
		nGSetupFailureIEs.List = append(nGSetupFailureIEs.List, ie)
	}

	return ngap.Encoder(pdu)
}

func rawBuildPathSwitchRequestFailure(aMFUENGAPID *ngapType.AMFUENGAPID, rANUENGAPID *ngapType.RANUENGAPID, pDUSessionResourceReleasedListPSFail *ngapType.PDUSessionResourceReleasedListPSFail, criticalityDiagnostics *ngapType.CriticalityDiagnostics) ([]byte, error) {
	var pdu ngapType.NGAPPDU

	pdu.Present = ngapType.NGAPPDUPresentUnsuccessfulOutcome
	pdu.UnsuccessfulOutcome = new(ngapType.UnsuccessfulOutcome)

	unsuccessfulOutcome := pdu.UnsuccessfulOutcome
	unsuccessfulOutcome.ProcedureCode.Value = ngapType.ProcedureCodePathSwitchRequest
	unsuccessfulOutcome.Criticality.Value = ngapType.CriticalityPresentReject

	unsuccessfulOutcome.Value.Present = ngapType.UnsuccessfulOutcomePresentPathSwitchRequestFailure
	unsuccessfulOutcome.Value.PathSwitchRequestFailure = new(ngapType.PathSwitchRequestFailure)

	pathSwitchRequestFailure := unsuccessfulOutcome.Value.PathSwitchRequestFailure
	pathSwitchRequestFailureIEs := &pathSwitchRequestFailure.ProtocolIEs
	pathSwitchRequestFailureIEs.List = make([]ngapType.PathSwitchRequestFailureIEs, 0, 4)

	{
		ie := ngapType.PathSwitchRequestFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDAMFUENGAPID
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.PathSwitchRequestFailureIEsPresentAMFUENGAPID
		ie.Value.AMFUENGAPID = aMFUENGAPID
		pathSwitchRequestFailureIEs.List = append(pathSwitchRequestFailureIEs.List, ie)
	}

	{
		ie := ngapType.PathSwitchRequestFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDRANUENGAPID
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.PathSwitchRequestFailureIEsPresentRANUENGAPID
		ie.Value.RANUENGAPID = rANUENGAPID
		pathSwitchRequestFailureIEs.List = append(pathSwitchRequestFailureIEs.List, ie)
	}

	{
		ie := ngapType.PathSwitchRequestFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDPDUSessionResourceReleasedListPSFail
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.PathSwitchRequestFailureIEsPresentPDUSessionResourceReleasedListPSFail
		ie.Value.PDUSessionResourceReleasedListPSFail = pDUSessionResourceReleasedListPSFail
		pathSwitchRequestFailureIEs.List = append(pathSwitchRequestFailureIEs.List, ie)
	}

	if criticalityDiagnostics != nil {
		ie := ngapType.PathSwitchRequestFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCriticalityDiagnostics
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.PathSwitchRequestFailureIEsPresentCriticalityDiagnostics
		ie.Value.CriticalityDiagnostics = criticalityDiagnostics
		pathSwitchRequestFailureIEs.List = append(pathSwitchRequestFailureIEs.List, ie)
	}

	return ngap.Encoder(pdu)
}

func rawBuildRANConfigurationUpdateFailure(cause *ngapType.Cause, timeToWait *ngapType.TimeToWait, criticalityDiagnostics *ngapType.CriticalityDiagnostics) ([]byte, error) {
	var pdu ngapType.NGAPPDU

	pdu.Present = ngapType.NGAPPDUPresentUnsuccessfulOutcome
	pdu.UnsuccessfulOutcome = new(ngapType.UnsuccessfulOutcome)

	unsuccessfulOutcome := pdu.UnsuccessfulOutcome
	unsuccessfulOutcome.ProcedureCode.Value = ngapType.ProcedureCodeRANConfigurationUpdate
	unsuccessfulOutcome.Criticality.Value = ngapType.CriticalityPresentReject

	unsuccessfulOutcome.Value.Present = ngapType.UnsuccessfulOutcomePresentRANConfigurationUpdateFailure
	unsuccessfulOutcome.Value.RANConfigurationUpdateFailure = new(ngapType.RANConfigurationUpdateFailure)

	rANConfigurationUpdateFailure := unsuccessfulOutcome.Value.RANConfigurationUpdateFailure
	rANConfigurationUpdateFailureIEs := &rANConfigurationUpdateFailure.ProtocolIEs
	rANConfigurationUpdateFailureIEs.List = make([]ngapType.RANConfigurationUpdateFailureIEs, 0, 3)

	{
		ie := ngapType.RANConfigurationUpdateFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCause
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.RANConfigurationUpdateFailureIEsPresentCause
		ie.Value.Cause = cause
		rANConfigurationUpdateFailureIEs.List = append(rANConfigurationUpdateFailureIEs.List, ie)
	}

	if timeToWait != nil {
		ie := ngapType.RANConfigurationUpdateFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDTimeToWait
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.RANConfigurationUpdateFailureIEsPresentTimeToWait
		ie.Value.TimeToWait = timeToWait
		rANConfigurationUpdateFailureIEs.List = append(rANConfigurationUpdateFailureIEs.List, ie)
	}

	if criticalityDiagnostics != nil {
		ie := ngapType.RANConfigurationUpdateFailureIEs{}
		ie.Id.Value = ngapType.ProtocolIEIDCriticalityDiagnostics
		ie.Criticality.Value = ngapType.CriticalityPresentIgnore
		ie.Value.Present = ngapType.RANConfigurationUpdateFailureIEsPresentCriticalityDiagnostics
		ie.Value.CriticalityDiagnostics = criticalityDiagnostics
		rANConfigurationUpdateFailureIEs.List = append(rANConfigurationUpdateFailureIEs.List, ie)
	}

	return ngap.Encoder(pdu)
}

func rawSendHandoverPreparationFailure(ran *context.AmfRan, aMFUENGAPID ngapType.AMFUENGAPID, rANUENGAPID ngapType.RANUENGAPID, cause ngapType.Cause, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	if ran == nil {
		logger.NgapLog.Error("Ran is nil")
		return
	}

	ran.Log.Info("Send HandoverPreparationFailure")

	pkt, err := rawBuildHandoverPreparationFailure(&aMFUENGAPID, &rANUENGAPID, &cause, criticalityDiagnostics)
	if err != nil {
		ran.Log.Errorf("Build HandoverPreparationFailure failed : %s", err.Error())
		return
	}

	ngap_message.SendToRan(ran, pkt)
}

func rawSendNGSetupFailure(ran *context.AmfRan, cause ngapType.Cause, timeToWait *ngapType.TimeToWait, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	if ran == nil {
		logger.NgapLog.Error("Ran is nil")
		return
	}

	ran.Log.Info("Send NGSetupFailure")

	pkt, err := rawBuildNGSetupFailure(&cause, timeToWait, criticalityDiagnostics)
	if err != nil {
		ran.Log.Errorf("Build NGSetupFailure failed : %s", err.Error())
		return
	}

	ngap_message.SendToRan(ran, pkt)
}

func rawSendPathSwitchRequestFailure(ran *context.AmfRan, aMFUENGAPID ngapType.AMFUENGAPID, rANUENGAPID ngapType.RANUENGAPID, pDUSessionResourceReleasedListPSFail ngapType.PDUSessionResourceReleasedListPSFail, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	if ran == nil {
		logger.NgapLog.Error("Ran is nil")
		return
	}

	ran.Log.Info("Send PathSwitchRequestFailure")

	pkt, err := rawBuildPathSwitchRequestFailure(&aMFUENGAPID, &rANUENGAPID, &pDUSessionResourceReleasedListPSFail, criticalityDiagnostics)
	if err != nil {
		ran.Log.Errorf("Build PathSwitchRequestFailure failed : %s", err.Error())
		return
	}

	ngap_message.SendToRan(ran, pkt)
}

func rawSendRANConfigurationUpdateFailure(ran *context.AmfRan, cause ngapType.Cause, timeToWait *ngapType.TimeToWait, criticalityDiagnostics *ngapType.CriticalityDiagnostics) {
	if ran == nil {
		logger.NgapLog.Error("Ran is nil")
		return
	}

	ran.Log.Info("Send RANConfigurationUpdateFailure")

	pkt, err := rawBuildRANConfigurationUpdateFailure(&cause, timeToWait, criticalityDiagnostics)
	if err != nil {
		ran.Log.Errorf("Build RANConfigurationUpdateFailure failed : %s", err.Error())
		return
	}

	ngap_message.SendToRan(ran, pkt)
}
