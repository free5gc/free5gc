/*
 * Nudr_DataRepository API OpenAPI file
 *
 * Unified Data Repository Service
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package processor

import (
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"

	"github.com/free5gc/openapi"
	"github.com/free5gc/openapi/models"
	udr_context "github.com/free5gc/udr/internal/context"
	db "github.com/free5gc/udr/internal/database"
	"github.com/free5gc/udr/internal/logger"
	"github.com/free5gc/udr/internal/util"
	"github.com/free5gc/util/mongoapi"
)

func (p *Processor) DeleteApplicationDataIndividualPfdFromDBProcedure(c *gin.Context, appID string) {
	filter := bson.M{"applicationId": appID}
	p.DeleteDataFromDB(db.APPDATA_PFD_DB_COLLECTION_NAME, filter)
	c.Status(http.StatusNoContent)
}

func (p *Processor) GetApplicationDataIndividualPfdFromDBProcedure(c *gin.Context, appID string) {
	filter := bson.M{"applicationId": appID}
	data, pd := p.GetDataFromDB(db.APPDATA_PFD_DB_COLLECTION_NAME, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("getApplicationDataIndividualPfdFromDB err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PutApplicationDataIndividualPfdToDBProcedure(
	c *gin.Context, appID string, pfdDataForApp *models.PfdDataForApp,
) {
	filter := bson.M{"applicationId": appID}
	data := util.ToBsonM(*pfdDataForApp)

	existed, err := mongoapi.RestfulAPIPutOne(db.APPDATA_PFD_DB_COLLECTION_NAME, filter, data)
	if err != nil {
		logger.DataRepoLog.Errorf("putApplicationDataIndividualPfdToDB err: %+v", err)
		c.JSON(http.StatusInternalServerError, nil)
		return
	}

	if existed {
		c.JSON(http.StatusOK, data)
	}
	c.JSON(http.StatusCreated, data)
}

func (p *Processor) GetApplicationDataPfdsFromDBProcedure(c *gin.Context, pfdsAppIDs []string) {
	filter := bson.M{}

	var matchedPfds []map[string]interface{}
	if len(pfdsAppIDs) == 0 {
		var err error
		matchedPfds, err = mongoapi.RestfulAPIGetMany(db.APPDATA_PFD_DB_COLLECTION_NAME, filter)
		if err != nil {
			logger.DataRepoLog.Errorf("getApplicationDataPfdsFromDB err: %+v", err)
			c.JSON(http.StatusOK, nil)
			return
		}
	} else {
		for _, v := range pfdsAppIDs {
			filter := bson.M{"applicationId": v}
			data, pd := p.GetDataFromDB(db.APPDATA_PFD_DB_COLLECTION_NAME, filter)
			if pd == nil {
				matchedPfds = append(matchedPfds, data)
			}
		}
	}
	c.JSON(http.StatusOK, matchedPfds)
}

func (p *Processor) PolicyDataBdtDataBdtReferenceIdDeleteProcedure(
	c *gin.Context, collName string, bdtReferenceId string,
) {
	filter := bson.M{"bdtReferenceId": bdtReferenceId}
	p.DeleteDataFromDB(collName, filter)
	c.Status(http.StatusNoContent)
}

func (p *Processor) PolicyDataBdtDataBdtReferenceIdGetProcedure(
	c *gin.Context, collName string, bdtReferenceId string,
) {
	filter := bson.M{"bdtReferenceId": bdtReferenceId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataBdtDataBdtReferenceIdGetProcedure err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
		return
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PolicyDataBdtDataBdtReferenceIdPutProcedure(
	c *gin.Context, collName string, bdtReferenceId string, bdtData models.BdtData,
) {
	putData := util.ToBsonM(bdtData)
	putData["bdtReferenceId"] = bdtReferenceId
	filter := bson.M{"bdtReferenceId": bdtReferenceId}

	existed, err := mongoapi.RestfulAPIPutOne(collName, filter, putData)
	if err != nil {
		logger.DataRepoLog.Errorf("putApplicationDataIndividualPfdToDB err: %+v", err)
		pd := util.ProblemDetailsUpspecified(err.Error())
		c.JSON(int(pd.Status), pd)
		return
	}

	if existed {
		PreHandlePolicyDataChangeNotification("", bdtReferenceId, bdtData)
	}
	c.JSON(http.StatusOK, putData)
}

func (p *Processor) PolicyDataBdtDataGetProcedure(c *gin.Context, collName string) {
	filter := bson.M{}
	bdtDataArray, err := mongoapi.RestfulAPIGetMany(collName, filter)
	if err != nil {
		logger.DataRepoLog.Errorf("PolicyDataBdtDataGetProcedure err: %+v", err)
		c.JSON(http.StatusOK, nil)
	}
	c.JSON(http.StatusOK, bdtDataArray)
}

func (p *Processor) PolicyDataPlmnsPlmnIdUePolicySetGetProcedure(c *gin.Context, collName string, plmnId string) {
	filter := bson.M{"plmnId": plmnId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataPlmnsPlmnIdUePolicySetGetProcedure err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
		return
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PolicyDataSponsorConnectivityDataSponsorIdGetProcedure(c *gin.Context, collName string,
	sponsorId string,
) {
	filter := bson.M{"sponsorId": sponsorId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataSponsorConnectivityDataSponsorIdGetProcedure err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
		return
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PolicyDataSubsToNotifyPostProcedure(
	c *gin.Context, PolicyDataSubscription models.PolicyDataSubscription,
) {
	udrSelf := udr_context.GetSelf()

	newSubscriptionID := strconv.Itoa(udrSelf.PolicyDataSubscriptionIDGenerator)
	udrSelf.PolicyDataSubscriptions[newSubscriptionID] = &PolicyDataSubscription
	udrSelf.PolicyDataSubscriptionIDGenerator++

	/* Contains the URI of the newly created resource, according
	   to the structure: {apiRoot}/subscription-data/subs-to-notify/{subsId} */
	locationHeader := fmt.Sprintf("%s/policy-data/subs-to-notify/%s", udrSelf.GetIPv4GroupUri(udr_context.NUDR_DR),
		newSubscriptionID)

	c.Header("Location", locationHeader)
	c.JSON(http.StatusCreated, PolicyDataSubscription)
}

func (p *Processor) PolicyDataSubsToNotifySubsIdDeleteProcedure(c *gin.Context, subsId string) {
	udrSelf := udr_context.GetSelf()
	_, ok := udrSelf.PolicyDataSubscriptions[subsId]
	if !ok {
		pd := util.ProblemDetailsNotFound("SUBSCRIPTION_NOT_FOUND")
		c.JSON(int(pd.Status), pd)
	}
	delete(udrSelf.PolicyDataSubscriptions, subsId)
	c.Status(http.StatusNoContent)
}

func (p *Processor) PolicyDataSubsToNotifySubsIdPutProcedure(c *gin.Context, subsId string,
	policyDataSubscription models.PolicyDataSubscription,
) {
	udrSelf := udr_context.GetSelf()
	_, ok := udrSelf.PolicyDataSubscriptions[subsId]
	if !ok {
		pd := util.ProblemDetailsNotFound("SUBSCRIPTION_NOT_FOUND")
		c.JSON(int(pd.Status), pd)
	}

	udrSelf.PolicyDataSubscriptions[subsId] = &policyDataSubscription
	c.JSON(http.StatusOK, policyDataSubscription)
}

func (p *Processor) PolicyDataUesUeIdAmDataGetProcedure(c *gin.Context, collName string,
	ueId string,
) {
	filter := bson.M{"ueId": ueId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdAmDataGetProcedure err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PolicyDataUesUeIdOperatorSpecificDataGetProcedure(c *gin.Context, collName string,
	ueId string,
) {
	filter := bson.M{"ueId": ueId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdOperatorSpecificDataGetProcedure err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
	}
	operatorSpecificDataContainerMap := data["operatorSpecificDataContainerMap"]
	c.JSON(http.StatusOK, operatorSpecificDataContainerMap)
}

func (p *Processor) PolicyDataUesUeIdOperatorSpecificDataPatchProcedure(c *gin.Context, collName string, ueId string,
	patchItem []models.PatchItem,
) {
	filter := bson.M{"ueId": ueId}

	patchJSON, err := json.Marshal(patchItem)
	if err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdOperatorSpecificDataPatchProcedure err: %+v", err)
		pd := util.ProblemDetailsModifyNotAllowed("")
		c.JSON(int(pd.Status), pd)
	}

	if err := mongoapi.RestfulAPIJSONPatchExtend(collName, filter, patchJSON,
		"operatorSpecificDataContainerMap"); err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdOperatorSpecificDataPatchProcedure err: %+v", err)
		pd := util.ProblemDetailsModifyNotAllowed("")
		c.JSON(int(pd.Status), pd)
	}
	c.Status(http.StatusNoContent)
}

func (p *Processor) PolicyDataUesUeIdOperatorSpecificDataPutProcedure(c *gin.Context, collName string, ueId string,
	OperatorSpecificDataContainer map[string]models.OperatorSpecificDataContainer,
) {
	filter := bson.M{"ueId": ueId}

	putData := map[string]interface{}{"operatorSpecificDataContainerMap": OperatorSpecificDataContainer}
	putData["ueId"] = ueId

	_, err := mongoapi.RestfulAPIPutOne(collName, filter, putData)
	if err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdOperatorSpecificDataPutProcedure err: %+v", err)
	}
	c.Status(http.StatusOK)
}

func (p *Processor) PolicyDataUesUeIdSmDataGetProcedure(
	c *gin.Context, collName string, ueId string, snssai models.Snssai,
	dnn string,
) {
	filter := bson.M{"ueId": ueId}

	smPolicyData, pd := p.GetDataFromDBWithArg(collName, filter, mongoapi.COLLATION_STRENGTH_IGNORE_CASE)
	if pd != nil {
		c.JSON(int(pd.Status), pd)
		return
	}

	hex_snssai := util.SnssaiModelsToHex(snssai)
	found := false
	smPolicySnssaiDatas, ok := smPolicyData["smPolicySnssaiData"].(map[string]interface{})
	if !ok {
		pd := util.ProblemDetailsNotFound("DATA_NOT_FOUND")
		c.JSON(int(pd.Status), pd)
		return
	}
	for cmpSnssai, v := range smPolicySnssaiDatas {
		if !strings.EqualFold(cmpSnssai, hex_snssai) {
			continue
		}
		smPolicySnssaiData, ok := v.(map[string]interface{})
		if !ok {
			break
		}
		smPolicyDnnDatas, ok := smPolicySnssaiData["smPolicyDnnData"].(map[string]interface{})
		if !ok {
			break
		}

		for cmpDnn := range smPolicyDnnDatas {
			if strings.EqualFold(cmpDnn, util.EscapeDnn(dnn)) {
				found = true
				break
			}
		}

		if found {
			break
		}
	}
	if !found {
		pd := util.ProblemDetailsNotFound("DATA_NOT_FOUND")
		c.JSON(int(pd.Status), pd)
		return
	}

	var smPolicyDataResp models.SmPolicyData
	err := json.Unmarshal(util.MapToByte(smPolicyData), &smPolicyDataResp)
	if err != nil {
		logger.DataRepoLog.Warnln(err)
	}
	tmpSmPolicySnssaiData := make(map[string]models.SmPolicySnssaiData)
	for snssai, snssaiData := range smPolicyDataResp.SmPolicySnssaiData {
		tmpSmPolicyDnnData := make(map[string]models.SmPolicyDnnData)
		for escapedDnn, dnnData := range snssaiData.SmPolicyDnnData {
			dnn := util.UnescapeDnn(escapedDnn)
			tmpSmPolicyDnnData[dnn] = dnnData
		}
		snssaiData.SmPolicyDnnData = tmpSmPolicyDnnData
		tmpSmPolicySnssaiData[snssai] = snssaiData
	}
	smPolicyDataResp.SmPolicySnssaiData = tmpSmPolicySnssaiData
	filter = bson.M{"ueId": ueId}
	usageMonDataMapArray, err := mongoapi.RestfulAPIGetMany("policyData.ues.smData.usageMonData", filter)
	if err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdSmDataGetProcedure err: %+v", err)
	}

	if !reflect.DeepEqual(usageMonDataMapArray, []map[string]interface{}{}) {
		var usageMonDataArray []models.UsageMonData
		if err := json.Unmarshal(util.MapArrayToByte(usageMonDataMapArray), &usageMonDataArray); err != nil {
			logger.DataRepoLog.Warnln(err)
		}
		smPolicyDataResp.UmData = make(map[string]models.UsageMonData)
		for _, element := range usageMonDataArray {
			smPolicyDataResp.UmData[element.LimitId] = element
		}
	}

	c.JSON(http.StatusOK, smPolicyDataResp)
}

func (p *Processor) PolicyDataUesUeIdSmDataPatchProcedure(c *gin.Context, collName string, ueId string,
	UsageMonData map[string]models.UsageMonData,
) {
	filter := bson.M{"ueId": ueId}

	successAll := true
	for k, usageMonData := range UsageMonData {
		limitId := k
		filterTmp := bson.M{"ueId": ueId, "limitId": limitId}
		if err := mongoapi.RestfulAPIMergePatch(collName, filterTmp, util.ToBsonM(usageMonData)); err != nil {
			successAll = false
		} else {
			var usageMonData models.UsageMonData
			usageMonDataBsonM, pd := p.GetDataFromDB(collName, filter)
			if pd != nil && pd.Status == http.StatusInternalServerError {
				logger.DataRepoLog.Errorf("PolicyDataUesUeIdSmDataPatchProcedure err: %s", pd.Detail)
				c.JSON(int(pd.Status), pd)
				return
			}
			if err := json.Unmarshal(util.MapToByte(usageMonDataBsonM), &usageMonData); err != nil {
				logger.DataRepoLog.Warnln(err)
			}
			PreHandlePolicyDataChangeNotification(ueId, limitId, usageMonData)
		}
	}

	if successAll {
		smPolicyDataBsonM, pd := p.GetDataFromDB(collName, filter)
		if pd != nil {
			logger.DataRepoLog.Errorf("PolicyDataUesUeIdSmDataPatchProcedure err: %s", pd.Detail)
			c.JSON(int(pd.Status), pd)
			return
		}
		var smPolicyData models.SmPolicyData
		if err := json.Unmarshal(util.MapToByte(smPolicyDataBsonM), &smPolicyData); err != nil {
			logger.DataRepoLog.Warnln(err)
		}

		collName := "policyData.ues.smData.usageMonData"
		filter := bson.M{"ueId": ueId}
		usageMonDataMapArray, err := mongoapi.RestfulAPIGetMany(collName, filter)
		if err != nil {
			logger.DataRepoLog.Errorf("PolicyDataUesUeIdSmDataPatchProcedure err: %+v", err)
		}

		if !reflect.DeepEqual(usageMonDataMapArray, []map[string]interface{}{}) {
			var usageMonDataArray []models.UsageMonData
			if err := json.Unmarshal(util.MapArrayToByte(usageMonDataMapArray), &usageMonDataArray); err != nil {
				logger.DataRepoLog.Warnln(err)
			}
			smPolicyData.UmData = make(map[string]models.UsageMonData)
			for _, element := range usageMonDataArray {
				smPolicyData.UmData[element.LimitId] = element
			}
		}
		PreHandlePolicyDataChangeNotification(ueId, "", smPolicyData)
		c.Status(http.StatusNoContent)
	}
	pd := util.ProblemDetailsModifyNotAllowed("")
	c.JSON(int(pd.Status), pd)
}

func (p *Processor) PolicyDataUesUeIdSmDataUsageMonIdDeleteProcedure(
	c *gin.Context, collName string, ueId string, usageMonId string,
) {
	filter := bson.M{"ueId": ueId, "usageMonId": usageMonId}
	p.DeleteDataFromDB(collName, filter)
	c.Status(http.StatusNoContent)
}

func (p *Processor) PolicyDataUesUeIdSmDataUsageMonIdGetProcedure(c *gin.Context, collName string, usageMonId string,
	ueId string,
) {
	filter := bson.M{"ueId": ueId, "usageMonId": usageMonId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdSmDataUsageMonIdGetProcedure err: %s", pd.Detail)
		pd := util.ProblemDetailsNotFound("DATA_NOT_FOUND")
		c.JSON(int(pd.Status), pd)
		return
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PolicyDataUesUeIdSmDataUsageMonIdPutProcedure(
	c *gin.Context, collName string, ueId string, usageMonId string,
	usageMonData models.UsageMonData,
) {
	putData := util.ToBsonM(usageMonData)
	putData["ueId"] = ueId
	putData["usageMonId"] = usageMonId
	filter := bson.M{"ueId": ueId, "usageMonId": usageMonId}

	_, err := mongoapi.RestfulAPIPutOne(collName, filter, putData)
	if err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdSmDataUsageMonIdPutProcedure err: %+v", err)
		pd := util.ProblemDetailsUpspecified("")
		c.JSON(int(pd.Status), pd)
		return
	}
	c.JSON(http.StatusOK, putData)
}

func (p *Processor) PolicyDataUesUeIdUePolicySetGetProcedure(c *gin.Context, collName string, ueId string) {
	filter := bson.M{"ueId": ueId}
	data, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdUePolicySetGetProcedure err: %s", pd.Detail)
		pd := util.ProblemDetailsNotFound("DATA_NOT_FOUND")
		c.JSON(int(pd.Status), pd)
		return
	}
	c.JSON(http.StatusOK, data)
}

func (p *Processor) PolicyDataUesUeIdUePolicySetPatchProcedure(c *gin.Context, collName string, ueId string,
	UePolicySet models.UePolicySet,
) {
	patchData := util.ToBsonM(UePolicySet)
	patchData["ueId"] = ueId
	filter := bson.M{"ueId": ueId}

	if err := mongoapi.RestfulAPIMergePatch(collName, filter, patchData); err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdUePolicySetPatchProcedure err: %+v", err)
		pd := util.ProblemDetailsModifyNotAllowed("")
		c.JSON(int(pd.Status), pd)
		return
	}

	var uePolicySet models.UePolicySet
	uePolicySetBsonM, pd := p.GetDataFromDB(collName, filter)
	if pd != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdUePolicySetPatchProcedure err: %s", pd.Detail)
		c.JSON(int(pd.Status), pd)
		return
	}
	if err := json.Unmarshal(util.MapToByte(uePolicySetBsonM), &uePolicySet); err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdUePolicySetPatchProcedure err: %+v", err)
		pd := openapi.ProblemDetailsSystemFailure(err.Error())
		c.JSON(int(pd.Status), pd)
		return
	}
	PreHandlePolicyDataChangeNotification(ueId, "", uePolicySet)
	c.Status(http.StatusNoContent)
}

func (p *Processor) PolicyDataUesUeIdUePolicySetPutProcedure(c *gin.Context, collName string, ueId string,
	UePolicySet models.UePolicySet,
) {
	putData := util.ToBsonM(UePolicySet)
	putData["ueId"] = ueId
	filter := bson.M{"ueId": ueId}

	existed, err := mongoapi.RestfulAPIPutOne(collName, filter, putData)
	if err != nil {
		logger.DataRepoLog.Errorf("PolicyDataUesUeIdUePolicySetPutProcedure err: %+v", err)
		c.Status(http.StatusInternalServerError)
	}
	if existed {
		c.Status(http.StatusNoContent)
	}
	c.JSON(http.StatusCreated, putData)
}
