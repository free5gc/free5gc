/*
 * Nudr_DataRepository API OpenAPI file
 *
 * Unified Data Repository Service
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package processor

import (
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"

	"github.com/free5gc/openapi/models"
	udr_context "github.com/free5gc/udr/internal/context"
	"github.com/free5gc/udr/internal/logger"
	"github.com/free5gc/udr/internal/util"
	"github.com/free5gc/util/mongoapi"
)

func (p *Processor) ApplicationDataInfluenceDataSubsToNotifyGetProcedure(
	c *gin.Context, dnn string, snssai *models.Snssai, internalGroupId, supi string,
) {
	var response []models.TrafficInfluSub

	udrSelf := udr_context.GetSelf()
	udrSelf.InfluenceDataSubscriptions.Range(func(key, value interface{}) bool {
		subs, ok := value.(*models.TrafficInfluSub)
		if !ok {
			logger.DataRepoLog.Errorf("Failed to load influence Data subscription ID [%+v]", key)
			return true
		} else if dnn != "" && !util.Contain(dnn, subs.Dnns) {
			return true
		} else if snssai != nil && !util.Contain(*snssai, subs.Snssais) {
			return true
		} else if internalGroupId != "" && !util.Contain(internalGroupId, subs.InternalGroupIds) {
			return true
		} else if supi != "" && !util.Contain(supi, subs.Supis) {
			return true
		} else {
			response = append(response, *subs)
		}
		return true
	})

	c.JSON(http.StatusOK, response)
}

func (p *Processor) ApplicationDataInfluenceDataSubsToNotifySubscriptionIdPostProcedure(
	c *gin.Context, subscriptionId string, request *models.TrafficInfluSub,
) {
	if len(request.Dnns) == 0 &&
		len(request.Snssais) == 0 &&
		len(request.InternalGroupIds) == 0 &&
		len(request.Supis) == 0 {
		pd := models.ProblemDetails{
			Status: http.StatusBadRequest,
			Detail: "At least one of DNNs, S-NSSAIs, Internal Group IDs or SUPIs shall be provided",
		}
		c.JSON(int(pd.Status), pd)
		return
	}

	if request.NotificationUri == "" {
		pd := models.ProblemDetails{
			Status: http.StatusBadRequest,
			Detail: "Notification URI shall be provided",
		}
		c.JSON(int(pd.Status), pd)
		return
	}

	udrSelf := udr_context.GetSelf()
	if subs, ok := udrSelf.InfluenceDataSubscriptions.Load(subscriptionId); ok && reflect.DeepEqual(*request, subs) {
		pd := &models.ProblemDetails{
			Status: http.StatusForbidden,
			Cause:  "UNSPECIFIED",
		}
		c.JSON(int(pd.Status), pd)
	} else {
		udrSelf.InfluenceDataSubscriptions.Store(subscriptionId, request)

		locationHeader := fmt.Sprintf(
			"%s/application-data/influenceData/subs-to-notify/%s",
			udr_context.GetSelf().GetIPv4GroupUri(udr_context.NUDR_DR), subscriptionId)
		c.Header("Location", locationHeader)
		c.JSON(http.StatusCreated, request)
	}
}

func (p *Processor) ApplicationDataInfluenceDataInfluenceIdDeleteProcedure(
	c *gin.Context, collName, influenceId string,
) {
	filter := bson.M{"influenceId": influenceId}

	mapData, err := mongoapi.RestfulAPIGetOne(collName, filter)
	if err != nil {
		logger.DataRepoLog.Errorf("ApplicationDataInfluenceDataInfluenceIdDeleteProcedure err: %+v", err)
		pd := util.ProblemDetailsUpspecified("")
		c.JSON(int(pd.Status), pd)
		return
	}
	var original *models.TrafficInfluData
	if len(mapData) != 0 {
		original = new(models.TrafficInfluData)
		byteData, err := json.Marshal(mapData)
		if err != nil {
			logger.DataRepoLog.Error(err.Error())
			pd := util.ProblemDetailsUpspecified(err.Error())
			c.JSON(int(pd.Status), pd)
			return
		}
		err = json.Unmarshal(byteData, &original)
		if err != nil {
			logger.DataRepoLog.Error(err.Error())
			pd := util.ProblemDetailsUpspecified(err.Error())
			c.JSON(int(pd.Status), pd)
			return
		}
	}

	if err := mongoapi.RestfulAPIDeleteOne(collName, filter); err != nil {
		logger.DataRepoLog.Errorf("InfluIdDelProcedure: %+v", err)
		pd := util.ProblemDetailsUpspecified(err.Error())
		c.JSON(int(pd.Status), pd)
		return
	}

	// Notify the change of influence data
	PreHandleInfluenceDataUpdateNotification(influenceId, original, nil)

	c.Status(http.StatusNoContent)
}
